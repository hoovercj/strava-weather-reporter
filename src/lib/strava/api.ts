/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Strava API v3
 * Strava API
 *
 * OpenAPI spec version: 3.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://www.strava.com/api/v3".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * A set of rolled-up statistics and totals for an athlete
 * @export
 * @interface ActivityStats
 */
export interface ActivityStats {
    /**
     * The longest distance ridden by the athlete.
     * @type {number}
     * @memberof ActivityStats
     */
    biggest_ride_distance?: number;
    /**
     * The highest climb ridden by the athlete.
     * @type {number}
     * @memberof ActivityStats
     */
    biggest_climb_elevation_gain?: number;
    /**
     * The recent (last 4 weeks) ride stats for the athlete.
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    recent_ride_totals?: ActivityTotal;
    /**
     * The recent (last 4 weeks) run stats for the athlete.
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    recent_run_totals?: ActivityTotal;
    /**
     * The recent (last 4 weeks) swim stats for the athlete.
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    recent_swim_totals?: ActivityTotal;
    /**
     * The year to date ride stats for the athlete.
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    ytd_ride_totals?: ActivityTotal;
    /**
     * The year to date run stats for the athlete.
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    ytd_run_totals?: ActivityTotal;
    /**
     * The year to date swim stats for the athlete.
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    ytd_swim_totals?: ActivityTotal;
    /**
     * The all time ride stats for the athlete.
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    all_ride_totals?: ActivityTotal;
    /**
     * The all time run stats for the athlete.
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    all_run_totals?: ActivityTotal;
    /**
     * The all time swim stats for the athlete.
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    all_swim_totals?: ActivityTotal;
}

/**
 * A roll-up of metrics pertaining to a set of activities. Values are in seconds and meters.
 * @export
 * @interface ActivityTotal
 */
export interface ActivityTotal {
    /**
     * The number of activities considered in this total.
     * @type {number}
     * @memberof ActivityTotal
     */
    count?: number;
    /**
     * The total distance covered by the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    distance?: number;
    /**
     * The total moving time of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    moving_time?: number;
    /**
     * The total elapsed time of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    elapsed_time?: number;
    /**
     * The total elevation gain of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    elevation_gain?: number;
    /**
     * The total number of achievements of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    achievement_count?: number;
}

/**
 * An enumeration of the types an activity may have.
 * @export
 * @enum {string}
 */
export enum ActivityType {
    AlpineSki = <any> 'AlpineSki',
    BackcountrySki = <any> 'BackcountrySki',
    Canoeing = <any> 'Canoeing',
    Crossfit = <any> 'Crossfit',
    EBikeRide = <any> 'EBikeRide',
    Elliptical = <any> 'Elliptical',
    Hike = <any> 'Hike',
    IceSkate = <any> 'IceSkate',
    InlineSkate = <any> 'InlineSkate',
    Kayaking = <any> 'Kayaking',
    Kitesurf = <any> 'Kitesurf',
    NordicSki = <any> 'NordicSki',
    Ride = <any> 'Ride',
    RockClimbing = <any> 'RockClimbing',
    RollerSki = <any> 'RollerSki',
    Rowing = <any> 'Rowing',
    Run = <any> 'Run',
    Snowboard = <any> 'Snowboard',
    Snowshoe = <any> 'Snowshoe',
    StairStepper = <any> 'StairStepper',
    StandUpPaddling = <any> 'StandUpPaddling',
    Surfing = <any> 'Surfing',
    Swim = <any> 'Swim',
    VirtualRide = <any> 'VirtualRide',
    VirtualRun = <any> 'VirtualRun',
    Walk = <any> 'Walk',
    WeightTraining = <any> 'WeightTraining',
    Windsurf = <any> 'Windsurf',
    Workout = <any> 'Workout',
    Yoga = <any> 'Yoga'
}

/**
 *
 * @export
 * @interface ActivityZone
 */
export interface ActivityZone {
    /**
     *
     * @type {number}
     * @memberof ActivityZone
     */
    score?: number;
    /**
     *
     * @type {TimedZoneDistribution}
     * @memberof ActivityZone
     */
    distribution_buckets?: TimedZoneDistribution;
    /**
     *
     * @type {string}
     * @memberof ActivityZone
     */
    type?: ActivityZone.TypeEnum;
    /**
     *
     * @type {boolean}
     * @memberof ActivityZone
     */
    sensor_based?: boolean;
    /**
     *
     * @type {number}
     * @memberof ActivityZone
     */
    points?: number;
    /**
     *
     * @type {boolean}
     * @memberof ActivityZone
     */
    custom_zones?: boolean;
    /**
     *
     * @type {number}
     * @memberof ActivityZone
     */
    max?: number;
}

/**
 * @export
 * @namespace ActivityZone
 */
export namespace ActivityZone {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Heartrate = <any> 'heartrate',
        Power = <any> 'power'
    }
}

/**
 *
 * @export
 * @interface BaseStream
 */
export interface BaseStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof BaseStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof BaseStream
     */
    resolution?: BaseStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof BaseStream
     */
    series_type?: BaseStream.SeriesTypeEnum;
}

/**
 * @export
 * @namespace BaseStream
 */
export namespace BaseStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 *
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * The unique identifier of this comment
     * @type {number}
     * @memberof Comment
     */
    id?: number;
    /**
     * The identifier of the activity this comment is related to
     * @type {number}
     * @memberof Comment
     */
    activity_id?: number;
    /**
     * The content of the comment
     * @type {string}
     * @memberof Comment
     */
    text?: string;
    /**
     *
     * @type {SummaryAthlete}
     * @memberof Comment
     */
    athlete?: SummaryAthlete;
    /**
     * The time at which this comment was created.
     * @type {Date}
     * @memberof Comment
     */
    created_at?: Date;
}

/**
 *
 * @export
 * @interface ExplorerResponse
 */
export interface ExplorerResponse {
    /**
     * The set of segments matching an explorer request
     * @type {Array&lt;ExplorerSegment&gt;}
     * @memberof ExplorerResponse
     */
    segments?: Array<ExplorerSegment>;
}

/**
 *
 * @export
 * @interface ExplorerSegment
 */
export interface ExplorerSegment {
    /**
     * The unique identifier of this segment
     * @type {number}
     * @memberof ExplorerSegment
     */
    id?: number;
    /**
     * The name of this segment
     * @type {string}
     * @memberof ExplorerSegment
     */
    name?: string;
    /**
     * The category of the climb
     * @type {number}
     * @memberof ExplorerSegment
     */
    climb_category?: number;
    /**
     * The description for the category of the climb
     * @type {string}
     * @memberof ExplorerSegment
     */
    climb_category_desc?: ExplorerSegment.ClimbCategoryDescEnum;
    /**
     * The segment's average grade, in percents
     * @type {number}
     * @memberof ExplorerSegment
     */
    avg_grade?: number;
    /**
     *
     * @type {LatLng}
     * @memberof ExplorerSegment
     */
    start_latlng?: LatLng;
    /**
     *
     * @type {LatLng}
     * @memberof ExplorerSegment
     */
    end_latlng?: LatLng;
    /**
     * The segments's evelation difference, in meters
     * @type {number}
     * @memberof ExplorerSegment
     */
    elev_difference?: number;
    /**
     * The segment's distance, in meters
     * @type {number}
     * @memberof ExplorerSegment
     */
    distance?: number;
    /**
     * The polyline of the segment
     * @type {string}
     * @memberof ExplorerSegment
     */
    points?: string;
}

/**
 * @export
 * @namespace ExplorerSegment
 */
export namespace ExplorerSegment {
    /**
     * @export
     * @enum {string}
     */
    export enum ClimbCategoryDescEnum {
        NC = <any> 'NC',
        _4 = <any> '4',
        _3 = <any> '3',
        _2 = <any> '2',
        _1 = <any> '1',
        HC = <any> 'HC'
    }
}

/**
 * Encapsulates the errors that may be returned from the API.
 * @export
 * @interface Fault
 */
export interface Fault {
    /**
     * The set of specific errors associated with this fault, if any.
     * @type {Array&lt;Error&gt;}
     * @memberof Fault
     */
    errors?: Array<Error>;
    /**
     * The message of the fault.
     * @type {string}
     * @memberof Fault
     */
    message?: string;
}

/**
 *
 * @export
 * @interface HeartRateZoneRanges
 */
export interface HeartRateZoneRanges {
    /**
     * Whether the athlete has set their own custom heart rate zones
     * @type {boolean}
     * @memberof HeartRateZoneRanges
     */
    custom_zones?: boolean;
    /**
     *
     * @type {ZoneRanges}
     * @memberof HeartRateZoneRanges
     */
    zones?: ZoneRanges;
}

/**
 *
 * @export
 * @interface Lap
 */
export interface Lap {
    /**
     * The unique identifier of this lap
     * @type {number}
     * @memberof Lap
     */
    id?: number;
    /**
     *
     * @type {MetaActivity}
     * @memberof Lap
     */
    activity?: MetaActivity;
    /**
     *
     * @type {MetaAthlete}
     * @memberof Lap
     */
    athlete?: MetaAthlete;
    /**
     * The lap's average cadence
     * @type {number}
     * @memberof Lap
     */
    average_cadence?: number;
    /**
     * The lap's average speed
     * @type {number}
     * @memberof Lap
     */
    average_speed?: number;
    /**
     * The lap's distance, in meters
     * @type {number}
     * @memberof Lap
     */
    distance?: number;
    /**
     * The lap's elapsed time, in seconds
     * @type {number}
     * @memberof Lap
     */
    elapsed_time?: number;
    /**
     * The start index of this effort in its activity's stream
     * @type {number}
     * @memberof Lap
     */
    start_index?: number;
    /**
     * The end index of this effort in its activity's stream
     * @type {number}
     * @memberof Lap
     */
    end_index?: number;
    /**
     * The index of this lap in the activity it belongs to
     * @type {number}
     * @memberof Lap
     */
    lap_index?: number;
    /**
     * The maximum speed of this lat, in meters per second
     * @type {number}
     * @memberof Lap
     */
    max_speed?: number;
    /**
     * The lap's moving time, in seconds
     * @type {number}
     * @memberof Lap
     */
    moving_time?: number;
    /**
     * The name of the lap
     * @type {string}
     * @memberof Lap
     */
    name?: string;
    /**
     * The athlete's pace zone during this lap
     * @type {number}
     * @memberof Lap
     */
    pace_zone?: number;
    /**
     *
     * @type {number}
     * @memberof Lap
     */
    split?: number;
    /**
     * The time at which the lap was started.
     * @type {Date}
     * @memberof Lap
     */
    start_date?: Date;
    /**
     * The time at which the lap was started in the local timezone.
     * @type {Date}
     * @memberof Lap
     */
    start_date_local?: Date;
    /**
     * The elevation gain of this lap, in meters
     * @type {number}
     * @memberof Lap
     */
    total_elevation_gain?: number;
}

/**
 * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
 * @export
 * @interface LatLng
 */
export interface LatLng extends Array<number> {
}

/**
 *
 * @export
 * @interface MembershipApplication
 */
export interface MembershipApplication {
    /**
     * Whether the application for membership was successfully submitted
     * @type {boolean}
     * @memberof MembershipApplication
     */
    success?: boolean;
    /**
     * Whether the membership is currently active
     * @type {boolean}
     * @memberof MembershipApplication
     */
    active?: boolean;
    /**
     * The membership status of this application
     * @type {string}
     * @memberof MembershipApplication
     */
    membership?: MembershipApplication.MembershipEnum;
}

/**
 * @export
 * @namespace MembershipApplication
 */
export namespace MembershipApplication {
    /**
     * @export
     * @enum {string}
     */
    export enum MembershipEnum {
        Member = <any> 'member',
        Pending = <any> 'pending'
    }
}

/**
 *
 * @export
 * @interface MetaActivity
 */
export interface MetaActivity {
    /**
     * The unique identifier of the activity
     * @type {number}
     * @memberof MetaActivity
     */
    id?: number;
}

/**
 *
 * @export
 * @interface MetaAthlete
 */
export interface MetaAthlete {
    /**
     * The unique identifier of the athlete
     * @type {number}
     * @memberof MetaAthlete
     */
    id?: number;
}

/**
 *
 * @export
 * @interface MetaClub
 */
export interface MetaClub {
    /**
     * The club's unique identifier.
     * @type {number}
     * @memberof MetaClub
     */
    id?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof MetaClub
     */
    resource_state?: number;
    /**
     * The club's name.
     * @type {string}
     * @memberof MetaClub
     */
    name?: string;
}

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * The code associated with this error.
     * @type {string}
     * @memberof ModelError
     */
    code?: string;
    /**
     * The specific field or aspect of the resource associated with this error.
     * @type {string}
     * @memberof ModelError
     */
    field?: string;
    /**
     * The type of resource associated with this error.
     * @type {string}
     * @memberof ModelError
     */
    resource?: string;
}

/**
 *
 * @export
 * @interface PhotosSummary
 */
export interface PhotosSummary {
    /**
     * The number of photos
     * @type {number}
     * @memberof PhotosSummary
     */
    count?: number;
    /**
     *
     * @type {PhotosSummaryPrimary}
     * @memberof PhotosSummary
     */
    primary?: PhotosSummaryPrimary;
}

/**
 *
 * @export
 * @interface PhotosSummaryPrimary
 */
export interface PhotosSummaryPrimary {
    /**
     *
     * @type {number}
     * @memberof PhotosSummaryPrimary
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof PhotosSummaryPrimary
     */
    source?: number;
    /**
     *
     * @type {string}
     * @memberof PhotosSummaryPrimary
     */
    unique_id?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof PhotosSummaryPrimary
     */
    urls?: { [key: string]: string; };
}

/**
 *
 * @export
 * @interface PolylineMap
 */
export interface PolylineMap {
    /**
     * The identifier of the map
     * @type {string}
     * @memberof PolylineMap
     */
    id?: string;
    /**
     * The polyline of the map
     * @type {string}
     * @memberof PolylineMap
     */
    polyline?: string;
    /**
     * The summary polyline of the map
     * @type {string}
     * @memberof PolylineMap
     */
    summary_polyline?: string;
}

/**
 *
 * @export
 * @interface PowerZoneRanges
 */
export interface PowerZoneRanges {
    /**
     *
     * @type {ZoneRanges}
     * @memberof PowerZoneRanges
     */
    zones?: ZoneRanges;
}

/**
 *
 * @export
 * @interface Route
 */
export interface Route {
    /**
     *
     * @type {SummaryAthlete}
     * @memberof Route
     */
    athlete?: SummaryAthlete;
    /**
     * The description of the route
     * @type {string}
     * @memberof Route
     */
    description?: string;
    /**
     * The route's distance, in meters
     * @type {number}
     * @memberof Route
     */
    distance?: number;
    /**
     * The route's elevation gain.
     * @type {number}
     * @memberof Route
     */
    elevation_gain?: number;
    /**
     * The unique identifier of this route
     * @type {number}
     * @memberof Route
     */
    id?: number;
    /**
     *
     * @type {PolylineMap}
     * @memberof Route
     */
    map?: PolylineMap;
    /**
     * The name of this route
     * @type {string}
     * @memberof Route
     */
    name?: string;
    /**
     * Whether this route is private
     * @type {boolean}
     * @memberof Route
     */
    _private?: boolean;
    /**
     * Whether this route is starred by the logged-in athlete
     * @type {boolean}
     * @memberof Route
     */
    starred?: boolean;
    /**
     *
     * @type {number}
     * @memberof Route
     */
    timestamp?: number;
    /**
     * This route's type (1 for ride, 2 for runs)
     * @type {number}
     * @memberof Route
     */
    type?: number;
    /**
     * This route's sub-type (1 for road, 2 for mountain bike, 3 for cross, 4 for trail, 5 for mixed)
     * @type {number}
     * @memberof Route
     */
    sub_type?: number;
    /**
     * The segments traversed by this route
     * @type {Array&lt;SummarySegment&gt;}
     * @memberof Route
     */
    segments?: Array<SummarySegment>;
    /**
     * The directions of this route
     * @type {Array&lt;RouteDirection&gt;}
     * @memberof Route
     */
    directions?: Array<RouteDirection>;
}

/**
 *
 * @export
 * @interface RouteDirection
 */
export interface RouteDirection {
    /**
     * The distance in the route at which the action applies
     * @type {number}
     * @memberof RouteDirection
     */
    distance?: number;
    /**
     * The action of this direction
     * @type {number}
     * @memberof RouteDirection
     */
    action?: number;
    /**
     *
     * @type {string}
     * @memberof RouteDirection
     */
    name?: string;
}

/**
 *
 * @export
 * @interface RunningRace
 */
export interface RunningRace {
    /**
     * The unique identifier of this race.
     * @type {number}
     * @memberof RunningRace
     */
    id?: number;
    /**
     * The name of this race.
     * @type {string}
     * @memberof RunningRace
     */
    name?: string;
    /**
     * The type of this race.
     * @type {number}
     * @memberof RunningRace
     */
    running_race_type?: number;
    /**
     * The race's distance, in meters.
     * @type {number}
     * @memberof RunningRace
     */
    distance?: number;
    /**
     * The time at which the race begins started in the local timezone.
     * @type {Date}
     * @memberof RunningRace
     */
    start_date_local?: Date;
    /**
     * The name of the city in which the race is taking place.
     * @type {string}
     * @memberof RunningRace
     */
    city?: string;
    /**
     * The name of the state or geographical region in which the race is taking place.
     * @type {string}
     * @memberof RunningRace
     */
    state?: string;
    /**
     * The name of the country in which the race is taking place.
     * @type {string}
     * @memberof RunningRace
     */
    country?: string;
    /**
     * The set of routes that cover this race's course.
     * @type {Array&lt;number&gt;}
     * @memberof RunningRace
     */
    route_ids?: Array<number>;
    /**
     * The unit system in which the race should be displayed.
     * @type {string}
     * @memberof RunningRace
     */
    measurement_preference?: RunningRace.MeasurementPreferenceEnum;
    /**
     * The vanity URL of this race on Strava.
     * @type {string}
     * @memberof RunningRace
     */
    url?: string;
    /**
     * The URL of this race's website.
     * @type {string}
     * @memberof RunningRace
     */
    website_url?: string;
}

/**
 * @export
 * @namespace RunningRace
 */
export namespace RunningRace {
    /**
     * @export
     * @enum {string}
     */
    export enum MeasurementPreferenceEnum {
        Feet = <any> 'feet',
        Meters = <any> 'meters'
    }
}

/**
 * A
 * @export
 * @interface SegmentLeaderboard
 */
export interface SegmentLeaderboard {
    /**
     * The total number of entries for this leaderboard
     * @type {number}
     * @memberof SegmentLeaderboard
     */
    entry_count?: number;
    /**
     * Deprecated, use entry_count
     * @type {number}
     * @memberof SegmentLeaderboard
     */
    effort_count?: number;
    /**
     *
     * @type {string}
     * @memberof SegmentLeaderboard
     */
    kom_type?: SegmentLeaderboard.KomTypeEnum;
    /**
     *
     * @type {Array&lt;SegmentLeaderboardEntry&gt;}
     * @memberof SegmentLeaderboard
     */
    entries?: Array<SegmentLeaderboardEntry>;
}

/**
 * @export
 * @namespace SegmentLeaderboard
 */
export namespace SegmentLeaderboard {
    /**
     * @export
     * @enum {string}
     */
    export enum KomTypeEnum {
        Kom = <any> 'kom',
        Cr = <any> 'cr'
    }
}

/**
 * A row in a segment leaderboard
 * @export
 * @interface SegmentLeaderboardEntry
 */
export interface SegmentLeaderboardEntry {
    /**
     * The public name of the athlete
     * @type {string}
     * @memberof SegmentLeaderboardEntry
     */
    athlete_name?: string;
    /**
     * The elapsed of the segment effort associated with this entry
     * @type {number}
     * @memberof SegmentLeaderboardEntry
     */
    elapsed_time?: number;
    /**
     * The moving of the segment effort associated with this entry
     * @type {number}
     * @memberof SegmentLeaderboardEntry
     */
    moving_time?: number;
    /**
     * The time at which the effort was started.
     * @type {Date}
     * @memberof SegmentLeaderboardEntry
     */
    start_date?: Date;
    /**
     * The time at which the effort was started in the local timezone.
     * @type {Date}
     * @memberof SegmentLeaderboardEntry
     */
    start_date_local?: Date;
    /**
     * The rank of this entry in the leaderboard
     * @type {number}
     * @memberof SegmentLeaderboardEntry
     */
    rank?: number;
}

/**
 *
 * @export
 * @interface Split
 */
export interface Split {
    /**
     * The average speed of this split, in meters per second
     * @type {number}
     * @memberof Split
     */
    average_speed?: number;
    /**
     * The distance of this split, in meters
     * @type {number}
     * @memberof Split
     */
    distance?: number;
    /**
     * The elapsed time of this split, in seconds
     * @type {number}
     * @memberof Split
     */
    elapsed_time?: number;
    /**
     * The elevation difference of this split, in meters
     * @type {number}
     * @memberof Split
     */
    elevation_difference?: number;
    /**
     * The pacing zone of this split
     * @type {number}
     * @memberof Split
     */
    pace_zone?: number;
    /**
     * The moving time of this split, in seconds
     * @type {number}
     * @memberof Split
     */
    moving_time?: number;
    /**
     * N/A
     * @type {number}
     * @memberof Split
     */
    split?: number;
}

/**
 *
 * @export
 * @interface StreamSet
 */
export interface StreamSet {
    /**
     *
     * @type {TimeStream}
     * @memberof StreamSet
     */
    time?: TimeStream;
    /**
     *
     * @type {DistanceStream}
     * @memberof StreamSet
     */
    distance?: DistanceStream;
    /**
     *
     * @type {LatLngStream}
     * @memberof StreamSet
     */
    latlng?: LatLngStream;
    /**
     *
     * @type {AltitudeStream}
     * @memberof StreamSet
     */
    altitude?: AltitudeStream;
    /**
     *
     * @type {SmoothVelocityStream}
     * @memberof StreamSet
     */
    velocity_smooth?: SmoothVelocityStream;
    /**
     *
     * @type {HeartrateStream}
     * @memberof StreamSet
     */
    heartrate?: HeartrateStream;
    /**
     *
     * @type {CadenceStream}
     * @memberof StreamSet
     */
    cadence?: CadenceStream;
    /**
     *
     * @type {PowerStream}
     * @memberof StreamSet
     */
    watts?: PowerStream;
    /**
     *
     * @type {TemperatureStream}
     * @memberof StreamSet
     */
    temp?: TemperatureStream;
    /**
     *
     * @type {MovingStream}
     * @memberof StreamSet
     */
    moving?: MovingStream;
    /**
     *
     * @type {SmoothGradeStream}
     * @memberof StreamSet
     */
    grade_smooth?: SmoothGradeStream;
}

/**
 *
 * @export
 * @interface SummaryGear
 */
export interface SummaryGear {
    /**
     * The gear's unique identifier.
     * @type {string}
     * @memberof SummaryGear
     */
    id?: string;
    /**
     * Resource state, indicates level of detail. Possible values: 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof SummaryGear
     */
    resource_state?: number;
    /**
     * Whether this gear's is the owner's default one.
     * @type {boolean}
     * @memberof SummaryGear
     */
    primary?: boolean;
    /**
     * The gear's name.
     * @type {string}
     * @memberof SummaryGear
     */
    name?: string;
    /**
     * The distance logged with this gear.
     * @type {number}
     * @memberof SummaryGear
     */
    distance?: number;
}

/**
 *
 * @export
 * @interface SummarySegment
 */
export interface SummarySegment {
    /**
     * The unique identifier of this segment
     * @type {number}
     * @memberof SummarySegment
     */
    id?: number;
    /**
     * The name of this segment
     * @type {string}
     * @memberof SummarySegment
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof SummarySegment
     */
    activity_type?: SummarySegment.ActivityTypeEnum;
    /**
     * The segment's distance, in meters
     * @type {number}
     * @memberof SummarySegment
     */
    distance?: number;
    /**
     * The segment's average grade, in percents
     * @type {number}
     * @memberof SummarySegment
     */
    average_grade?: number;
    /**
     * The segments's maximum grade, in percents
     * @type {number}
     * @memberof SummarySegment
     */
    maximum_grade?: number;
    /**
     * The segments's highest elevation, in meters
     * @type {number}
     * @memberof SummarySegment
     */
    elevation_high?: number;
    /**
     * The segments's lowest elevation, in meters
     * @type {number}
     * @memberof SummarySegment
     */
    elevation_low?: number;
    /**
     *
     * @type {LatLng}
     * @memberof SummarySegment
     */
    start_latlng?: LatLng;
    /**
     *
     * @type {LatLng}
     * @memberof SummarySegment
     */
    end_latlng?: LatLng;
    /**
     * The category of the climb
     * @type {number}
     * @memberof SummarySegment
     */
    climb_category?: number;
    /**
     * The segments's city.
     * @type {string}
     * @memberof SummarySegment
     */
    city?: string;
    /**
     * The segments's state or geographical region.
     * @type {string}
     * @memberof SummarySegment
     */
    state?: string;
    /**
     * The segment's country.
     * @type {string}
     * @memberof SummarySegment
     */
    country?: string;
    /**
     * Whether this segment is private.
     * @type {boolean}
     * @memberof SummarySegment
     */
    _private?: boolean;
    /**
     *
     * @type {SummarySegmentEffort}
     * @memberof SummarySegment
     */
    athlete_pr_effort?: SummarySegmentEffort;
}

/**
 * @export
 * @namespace SummarySegment
 */
export namespace SummarySegment {
    /**
     * @export
     * @enum {string}
     */
    export enum ActivityTypeEnum {
        Ride = <any> 'Ride',
        Run = <any> 'Run'
    }
}

/**
 *
 * @export
 * @interface SummarySegmentEffort
 */
export interface SummarySegmentEffort {
    /**
     * The unique identifier of this effort
     * @type {number}
     * @memberof SummarySegmentEffort
     */
    id?: number;
    /**
     * The effort's elapsed time
     * @type {number}
     * @memberof SummarySegmentEffort
     */
    elapsed_time?: number;
    /**
     * The time at which the effort was started.
     * @type {Date}
     * @memberof SummarySegmentEffort
     */
    start_date?: Date;
    /**
     * The time at which the effort was started in the local timezone.
     * @type {Date}
     * @memberof SummarySegmentEffort
     */
    start_date_local?: Date;
    /**
     * The effort's distance in meters
     * @type {number}
     * @memberof SummarySegmentEffort
     */
    distance?: number;
    /**
     * Whether this effort is the current best on the leaderboard
     * @type {boolean}
     * @memberof SummarySegmentEffort
     */
    is_kom?: boolean;
}

/**
 * Stores the exclusive ranges representing zones and the time spent in each.
 * @export
 * @interface TimedZoneDistribution
 */
export interface TimedZoneDistribution extends Array<TimedZoneRange> {
}

/**
 *
 * @export
 * @interface UpdatableActivity
 */
export interface UpdatableActivity {
    /**
     * Whether this activity is a commute
     * @type {boolean}
     * @memberof UpdatableActivity
     */
    commute?: boolean;
    /**
     * Whether this activity was recorded on a training machine
     * @type {boolean}
     * @memberof UpdatableActivity
     */
    trainer?: boolean;
    /**
     * The description of the activity
     * @type {string}
     * @memberof UpdatableActivity
     */
    description?: string;
    /**
     * The name of the activity
     * @type {string}
     * @memberof UpdatableActivity
     */
    name?: string;
    /**
     *
     * @type {ActivityType}
     * @memberof UpdatableActivity
     */
    type?: ActivityType;
    /**
     * Whether this activity is private
     * @type {boolean}
     * @memberof UpdatableActivity
     */
    _private?: boolean;
    /**
     * Identifier for the gear associated with the activity. ‘none’ clears gear from activity
     * @type {string}
     * @memberof UpdatableActivity
     */
    gear_id?: string;
}

/**
 *
 * @export
 * @interface Upload
 */
export interface Upload {
    /**
     * The unique identifier of the upload
     * @type {number}
     * @memberof Upload
     */
    id?: number;
    /**
     * The external identifier of the upload
     * @type {string}
     * @memberof Upload
     */
    external_id?: string;
    /**
     * The error associated with this upload
     * @type {string}
     * @memberof Upload
     */
    error?: string;
    /**
     * The status of this upload
     * @type {string}
     * @memberof Upload
     */
    status?: string;
    /**
     * The identifier of the activity this upload resulted into
     * @type {number}
     * @memberof Upload
     */
    activity_id?: number;
}

/**
 *
 * @export
 * @interface ZoneRange
 */
export interface ZoneRange {
    /**
     * The minimum value in the range.
     * @type {number}
     * @memberof ZoneRange
     */
    min?: number;
    /**
     * The maximum value in the range.
     * @type {number}
     * @memberof ZoneRange
     */
    max?: number;
}

/**
 *
 * @export
 * @interface ZoneRanges
 */
export interface ZoneRanges extends Array<ZoneRange> {
}

/**
 *
 * @export
 * @interface Zones
 */
export interface Zones {
    /**
     *
     * @type {HeartRateZoneRanges}
     * @memberof Zones
     */
    heart_rate?: HeartRateZoneRanges;
    /**
     *
     * @type {PowerZoneRanges}
     * @memberof Zones
     */
    power?: PowerZoneRanges;
}

/**
 *
 * @export
 * @interface AltitudeStream
 */
export interface AltitudeStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof AltitudeStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof AltitudeStream
     */
    resolution?: AltitudeStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof AltitudeStream
     */
    series_type?: AltitudeStream.SeriesTypeEnum;
    /**
     * The sequence of altitude values for this stream, in meters
     * @type {Array&lt;number&gt;}
     * @memberof AltitudeStream
     */
    data?: Array<number>;
}

/**
 * @export
 * @namespace AltitudeStream
 */
export namespace AltitudeStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 *
 * @export
 * @interface CadenceStream
 */
export interface CadenceStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof CadenceStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof CadenceStream
     */
    resolution?: CadenceStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof CadenceStream
     */
    series_type?: CadenceStream.SeriesTypeEnum;
    /**
     * The sequence of cadence values for this stream, in rotations per minute
     * @type {Array&lt;number&gt;}
     * @memberof CadenceStream
     */
    data?: Array<number>;
}

/**
 * @export
 * @namespace CadenceStream
 */
export namespace CadenceStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 *
 * @export
 * @interface DetailedGear
 */
export interface DetailedGear {
    /**
     * The gear's unique identifier.
     * @type {string}
     * @memberof DetailedGear
     */
    id?: string;
    /**
     * Resource state, indicates level of detail. Possible values: 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof DetailedGear
     */
    resource_state?: number;
    /**
     * Whether this gear's is the owner's default one.
     * @type {boolean}
     * @memberof DetailedGear
     */
    primary?: boolean;
    /**
     * The gear's name.
     * @type {string}
     * @memberof DetailedGear
     */
    name?: string;
    /**
     * The distance logged with this gear.
     * @type {number}
     * @memberof DetailedGear
     */
    distance?: number;
    /**
     * The gear's brand name.
     * @type {string}
     * @memberof DetailedGear
     */
    brand_name?: string;
    /**
     * The gear's model name.
     * @type {string}
     * @memberof DetailedGear
     */
    model_name?: string;
    /**
     * The gear's frame type (bike only).
     * @type {number}
     * @memberof DetailedGear
     */
    frame_type?: number;
    /**
     * The gear's description.
     * @type {string}
     * @memberof DetailedGear
     */
    description?: string;
}

/**
 *
 * @export
 * @interface DetailedSegment
 */
export interface DetailedSegment {
    /**
     * The unique identifier of this segment
     * @type {number}
     * @memberof DetailedSegment
     */
    id?: number;
    /**
     * The name of this segment
     * @type {string}
     * @memberof DetailedSegment
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof DetailedSegment
     */
    activity_type?: DetailedSegment.ActivityTypeEnum;
    /**
     * The segment's distance, in meters
     * @type {number}
     * @memberof DetailedSegment
     */
    distance?: number;
    /**
     * The segment's average grade, in percents
     * @type {number}
     * @memberof DetailedSegment
     */
    average_grade?: number;
    /**
     * The segments's maximum grade, in percents
     * @type {number}
     * @memberof DetailedSegment
     */
    maximum_grade?: number;
    /**
     * The segments's highest elevation, in meters
     * @type {number}
     * @memberof DetailedSegment
     */
    elevation_high?: number;
    /**
     * The segments's lowest elevation, in meters
     * @type {number}
     * @memberof DetailedSegment
     */
    elevation_low?: number;
    /**
     *
     * @type {LatLng}
     * @memberof DetailedSegment
     */
    start_latlng?: LatLng;
    /**
     *
     * @type {LatLng}
     * @memberof DetailedSegment
     */
    end_latlng?: LatLng;
    /**
     * The category of the climb
     * @type {number}
     * @memberof DetailedSegment
     */
    climb_category?: number;
    /**
     * The segments's city.
     * @type {string}
     * @memberof DetailedSegment
     */
    city?: string;
    /**
     * The segments's state or geographical region.
     * @type {string}
     * @memberof DetailedSegment
     */
    state?: string;
    /**
     * The segment's country.
     * @type {string}
     * @memberof DetailedSegment
     */
    country?: string;
    /**
     * Whether this segment is private.
     * @type {boolean}
     * @memberof DetailedSegment
     */
    _private?: boolean;
    /**
     *
     * @type {SummarySegmentEffort}
     * @memberof DetailedSegment
     */
    athlete_pr_effort?: SummarySegmentEffort;
    /**
     * The time at which the segment was created.
     * @type {Date}
     * @memberof DetailedSegment
     */
    created_at?: Date;
    /**
     * The time at which the segment was last updated.
     * @type {Date}
     * @memberof DetailedSegment
     */
    updated_at?: Date;
    /**
     * The segment's total elevation gain.
     * @type {number}
     * @memberof DetailedSegment
     */
    total_elevation_gain?: number;
    /**
     *
     * @type {PolylineMap}
     * @memberof DetailedSegment
     */
    map?: PolylineMap;
    /**
     * The total number of efforts for this segment
     * @type {number}
     * @memberof DetailedSegment
     */
    effort_count?: number;
    /**
     * The number of unique athletes who have an effort for this segment
     * @type {number}
     * @memberof DetailedSegment
     */
    athlete_count?: number;
    /**
     * Whether this segment is considered hazardous
     * @type {boolean}
     * @memberof DetailedSegment
     */
    hazardous?: boolean;
    /**
     * The number of stars for this segment
     * @type {number}
     * @memberof DetailedSegment
     */
    star_count?: number;
}

/**
 * @export
 * @namespace DetailedSegment
 */
export namespace DetailedSegment {
    /**
     * @export
     * @enum {string}
     */
    export enum ActivityTypeEnum {
        Ride = <any> 'Ride',
        Run = <any> 'Run'
    }
}

/**
 *
 * @export
 * @interface DetailedSegmentEffort
 */
export interface DetailedSegmentEffort {
    /**
     * The unique identifier of this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    id?: number;
    /**
     * The effort's elapsed time
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    elapsed_time?: number;
    /**
     * The time at which the effort was started.
     * @type {Date}
     * @memberof DetailedSegmentEffort
     */
    start_date?: Date;
    /**
     * The time at which the effort was started in the local timezone.
     * @type {Date}
     * @memberof DetailedSegmentEffort
     */
    start_date_local?: Date;
    /**
     * The effort's distance in meters
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    distance?: number;
    /**
     * Whether this effort is the current best on the leaderboard
     * @type {boolean}
     * @memberof DetailedSegmentEffort
     */
    is_kom?: boolean;
    /**
     * The name of the segment on which this effort was performed
     * @type {string}
     * @memberof DetailedSegmentEffort
     */
    name?: string;
    /**
     *
     * @type {MetaActivity}
     * @memberof DetailedSegmentEffort
     */
    activity?: MetaActivity;
    /**
     *
     * @type {MetaAthlete}
     * @memberof DetailedSegmentEffort
     */
    athlete?: MetaAthlete;
    /**
     * The effort's moving time
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    moving_time?: number;
    /**
     * The start index of this effort in its activity's stream
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    start_index?: number;
    /**
     * The end index of this effort in its activity's stream
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    end_index?: number;
    /**
     * The effort's average cadence
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    average_cadence?: number;
    /**
     * The average wattage of this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    average_watts?: number;
    /**
     * For riding efforts, whether the wattage was reported by a dedicated recording device
     * @type {boolean}
     * @memberof DetailedSegmentEffort
     */
    device_watts?: boolean;
    /**
     * The heart heart rate of the athlete during this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    average_heartrate?: number;
    /**
     * The maximum heart rate of the athlete during this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    max_heartrate?: number;
    /**
     *
     * @type {SummarySegment}
     * @memberof DetailedSegmentEffort
     */
    segment?: SummarySegment;
    /**
     * The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    kom_rank?: number;
    /**
     * The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    pr_rank?: number;
    /**
     * Whether this effort should be hidden when viewed within an activity
     * @type {boolean}
     * @memberof DetailedSegmentEffort
     */
    hidden?: boolean;
}

/**
 *
 * @export
 * @interface DistanceStream
 */
export interface DistanceStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof DistanceStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof DistanceStream
     */
    resolution?: DistanceStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof DistanceStream
     */
    series_type?: DistanceStream.SeriesTypeEnum;
    /**
     * The sequence of distance values for this stream, in meters
     * @type {Array&lt;number&gt;}
     * @memberof DistanceStream
     */
    data?: Array<number>;
}

/**
 * @export
 * @namespace DistanceStream
 */
export namespace DistanceStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 *
 * @export
 * @interface HeartrateStream
 */
export interface HeartrateStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof HeartrateStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof HeartrateStream
     */
    resolution?: HeartrateStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof HeartrateStream
     */
    series_type?: HeartrateStream.SeriesTypeEnum;
    /**
     * The sequence of heart rate values for this stream, in beats per minute
     * @type {Array&lt;number&gt;}
     * @memberof HeartrateStream
     */
    data?: Array<number>;
}

/**
 * @export
 * @namespace HeartrateStream
 */
export namespace HeartrateStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 *
 * @export
 * @interface LatLngStream
 */
export interface LatLngStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof LatLngStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof LatLngStream
     */
    resolution?: LatLngStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof LatLngStream
     */
    series_type?: LatLngStream.SeriesTypeEnum;
    /**
     * The sequence of lat/long values for this stream
     * @type {Array&lt;LatLng&gt;}
     * @memberof LatLngStream
     */
    data?: Array<LatLng>;
}

/**
 * @export
 * @namespace LatLngStream
 */
export namespace LatLngStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 *
 * @export
 * @interface MovingStream
 */
export interface MovingStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof MovingStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof MovingStream
     */
    resolution?: MovingStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof MovingStream
     */
    series_type?: MovingStream.SeriesTypeEnum;
    /**
     * The sequence of moving values for this stream, as boolean values
     * @type {Array&lt;boolean&gt;}
     * @memberof MovingStream
     */
    data?: Array<boolean>;
}

/**
 * @export
 * @namespace MovingStream
 */
export namespace MovingStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 *
 * @export
 * @interface PowerStream
 */
export interface PowerStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof PowerStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof PowerStream
     */
    resolution?: PowerStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof PowerStream
     */
    series_type?: PowerStream.SeriesTypeEnum;
    /**
     * The sequence of power values for this stream, in watts
     * @type {Array&lt;number&gt;}
     * @memberof PowerStream
     */
    data?: Array<number>;
}

/**
 * @export
 * @namespace PowerStream
 */
export namespace PowerStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 *
 * @export
 * @interface SmoothGradeStream
 */
export interface SmoothGradeStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof SmoothGradeStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof SmoothGradeStream
     */
    resolution?: SmoothGradeStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof SmoothGradeStream
     */
    series_type?: SmoothGradeStream.SeriesTypeEnum;
    /**
     * The sequence of grade values for this stream, as percents of a grade
     * @type {Array&lt;number&gt;}
     * @memberof SmoothGradeStream
     */
    data?: Array<number>;
}

/**
 * @export
 * @namespace SmoothGradeStream
 */
export namespace SmoothGradeStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 *
 * @export
 * @interface SmoothVelocityStream
 */
export interface SmoothVelocityStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof SmoothVelocityStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof SmoothVelocityStream
     */
    resolution?: SmoothVelocityStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof SmoothVelocityStream
     */
    series_type?: SmoothVelocityStream.SeriesTypeEnum;
    /**
     * The sequence of velocity values for this stream, in meters per second
     * @type {Array&lt;number&gt;}
     * @memberof SmoothVelocityStream
     */
    data?: Array<number>;
}

/**
 * @export
 * @namespace SmoothVelocityStream
 */
export namespace SmoothVelocityStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 *
 * @export
 * @interface SummaryActivity
 */
export interface SummaryActivity {
    /**
     * The unique identifier of the activity
     * @type {number}
     * @memberof SummaryActivity
     */
    id?: number;
    /**
     * The identifier provided at upload time
     * @type {string}
     * @memberof SummaryActivity
     */
    external_id?: string;
    /**
     * The identifier of the upload that resulted in this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    upload_id?: number;
    /**
     *
     * @type {MetaAthlete}
     * @memberof SummaryActivity
     */
    athlete?: MetaAthlete;
    /**
     * The name of the activity
     * @type {string}
     * @memberof SummaryActivity
     */
    name?: string;
    /**
     * The activity's distance, in meters
     * @type {number}
     * @memberof SummaryActivity
     */
    distance?: number;
    /**
     * The activity's moving time, in seconds
     * @type {number}
     * @memberof SummaryActivity
     */
    moving_time?: number;
    /**
     * The activity's elapsed time, in seconds
     * @type {number}
     * @memberof SummaryActivity
     */
    elapsed_time?: number;
    /**
     * The activity's total elevation gain.
     * @type {number}
     * @memberof SummaryActivity
     */
    total_elevation_gain?: number;
    /**
     * The activity's highest elevation, in meters
     * @type {number}
     * @memberof SummaryActivity
     */
    elev_high?: number;
    /**
     * The activity's lowest elevation, in meters
     * @type {number}
     * @memberof SummaryActivity
     */
    elev_low?: number;
    /**
     *
     * @type {ActivityType}
     * @memberof SummaryActivity
     */
    type?: ActivityType;
    /**
     * The time at which the activity was started.
     * @type {Date}
     * @memberof SummaryActivity
     */
    start_date?: Date;
    /**
     * The time at which the activity was started in the local timezone.
     * @type {Date}
     * @memberof SummaryActivity
     */
    start_date_local?: Date;
    /**
     * The timezone of the activity
     * @type {string}
     * @memberof SummaryActivity
     */
    timezone?: string;
    /**
     *
     * @type {LatLng}
     * @memberof SummaryActivity
     */
    start_latlng?: LatLng;
    /**
     *
     * @type {LatLng}
     * @memberof SummaryActivity
     */
    end_latlng?: LatLng;
    /**
     * The number of achievements gained during this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    achievement_count?: number;
    /**
     * The number of kudos given for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    kudos_count?: number;
    /**
     * The number of comments for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    comment_count?: number;
    /**
     * The number of athletes for taking part in a group activity
     * @type {number}
     * @memberof SummaryActivity
     */
    athlete_count?: number;
    /**
     * The number of Instagram photos for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    photo_count?: number;
    /**
     * The number of Instagram and Strava photos for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    total_photo_count?: number;
    /**
     *
     * @type {PolylineMap}
     * @memberof SummaryActivity
     */
    map?: PolylineMap;
    /**
     * Whether this activity was recorded on a training machine
     * @type {boolean}
     * @memberof SummaryActivity
     */
    trainer?: boolean;
    /**
     * Whether this activity is a commute
     * @type {boolean}
     * @memberof SummaryActivity
     */
    commute?: boolean;
    /**
     * Whether this activity was created manually
     * @type {boolean}
     * @memberof SummaryActivity
     */
    manual?: boolean;
    /**
     * Whether this activity is private
     * @type {boolean}
     * @memberof SummaryActivity
     */
    _private?: boolean;
    /**
     * Whether this activity is flagged
     * @type {boolean}
     * @memberof SummaryActivity
     */
    flagged?: boolean;
    /**
     * The activity's workout type
     * @type {number}
     * @memberof SummaryActivity
     */
    workout_type?: number;
    /**
     * The activity's average speed, in meters per second
     * @type {number}
     * @memberof SummaryActivity
     */
    average_speed?: number;
    /**
     * The activity's max speed, in meters per second
     * @type {number}
     * @memberof SummaryActivity
     */
    max_speed?: number;
    /**
     * Whether the logged-in athlete has kudoed this activity
     * @type {boolean}
     * @memberof SummaryActivity
     */
    has_kudoed?: boolean;
    /**
     * The id of the gear for the activity
     * @type {string}
     * @memberof SummaryActivity
     */
    gear_id?: string;
    /**
     * The total work done in kilojoules during this activity. Rides only
     * @type {number}
     * @memberof SummaryActivity
     */
    kilojoules?: number;
    /**
     * Average power output in watts during this activity. Rides only
     * @type {number}
     * @memberof SummaryActivity
     */
    average_watts?: number;
    /**
     * Whether the watts are from a power meter, false if estimated
     * @type {boolean}
     * @memberof SummaryActivity
     */
    device_watts?: boolean;
    /**
     * Rides with power meter data only
     * @type {number}
     * @memberof SummaryActivity
     */
    max_watts?: number;
    /**
     * Similar to Normalized Power. Rides with power meter data only
     * @type {number}
     * @memberof SummaryActivity
     */
    weighted_average_watts?: number;
}

/**
 *
 * @export
 * @interface SummaryAthlete
 */
export interface SummaryAthlete {
    /**
     * The unique identifier of the athlete
     * @type {number}
     * @memberof SummaryAthlete
     */
    id?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof SummaryAthlete
     */
    resource_state?: number;
    /**
     * The athlete's first name.
     * @type {string}
     * @memberof SummaryAthlete
     */
    firstname?: string;
    /**
     * The athlete's last name.
     * @type {string}
     * @memberof SummaryAthlete
     */
    lastname?: string;
    /**
     * URL to a 62x62 pixel profile picture.
     * @type {string}
     * @memberof SummaryAthlete
     */
    profile_medium?: string;
    /**
     * URL to a 124x124 pixel profile picture.
     * @type {string}
     * @memberof SummaryAthlete
     */
    profile?: string;
    /**
     * The athlete's city.
     * @type {string}
     * @memberof SummaryAthlete
     */
    city?: string;
    /**
     * The athlete's state or geographical region.
     * @type {string}
     * @memberof SummaryAthlete
     */
    state?: string;
    /**
     * The athlete's country.
     * @type {string}
     * @memberof SummaryAthlete
     */
    country?: string;
    /**
     * The athlete's sex.
     * @type {string}
     * @memberof SummaryAthlete
     */
    sex?: SummaryAthlete.SexEnum;
    /**
     * Whether the currently logged-in athlete follows this athlete.
     * @type {string}
     * @memberof SummaryAthlete
     */
    friend?: SummaryAthlete.FriendEnum;
    /**
     * Whether this athlete follows the currently logged-in athlete.
     * @type {string}
     * @memberof SummaryAthlete
     */
    follower?: SummaryAthlete.FollowerEnum;
    /**
     * The athlete's premium status.
     * @type {boolean}
     * @memberof SummaryAthlete
     */
    premium?: boolean;
    /**
     * The time at which the athlete was created.
     * @type {Date}
     * @memberof SummaryAthlete
     */
    created_at?: Date;
    /**
     * The time at which the athlete was last updated.
     * @type {Date}
     * @memberof SummaryAthlete
     */
    updated_at?: Date;
}

/**
 * @export
 * @namespace SummaryAthlete
 */
export namespace SummaryAthlete {
    /**
     * @export
     * @enum {string}
     */
    export enum SexEnum {
        M = <any> 'M',
        F = <any> 'F'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FriendEnum {
        Pending = <any> 'pending',
        Accepted = <any> 'accepted',
        Blocked = <any> 'blocked'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FollowerEnum {
        Pending = <any> 'pending',
        Accepted = <any> 'accepted',
        Blocked = <any> 'blocked'
    }
}

/**
 *
 * @export
 * @interface SummaryClub
 */
export interface SummaryClub {
    /**
     * The club's unique identifier.
     * @type {number}
     * @memberof SummaryClub
     */
    id?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof SummaryClub
     */
    resource_state?: number;
    /**
     * The club's name.
     * @type {string}
     * @memberof SummaryClub
     */
    name?: string;
    /**
     * URL to a 60x60 pixel profile picture.
     * @type {string}
     * @memberof SummaryClub
     */
    profile_medium?: string;
    /**
     * URL to a ~1185x580 pixel cover photo.
     * @type {string}
     * @memberof SummaryClub
     */
    cover_photo?: string;
    /**
     * URL to a ~360x176  pixel cover photo.
     * @type {string}
     * @memberof SummaryClub
     */
    cover_photo_small?: string;
    /**
     *
     * @type {string}
     * @memberof SummaryClub
     */
    sport_type?: SummaryClub.SportTypeEnum;
    /**
     * The club's city.
     * @type {string}
     * @memberof SummaryClub
     */
    city?: string;
    /**
     * The club's state or geographical region.
     * @type {string}
     * @memberof SummaryClub
     */
    state?: string;
    /**
     * The club's country.
     * @type {string}
     * @memberof SummaryClub
     */
    country?: string;
    /**
     * Whether the club is private.
     * @type {boolean}
     * @memberof SummaryClub
     */
    _private?: boolean;
    /**
     * The club's member count.
     * @type {number}
     * @memberof SummaryClub
     */
    member_count?: number;
    /**
     * Whether the club is featured or not.
     * @type {boolean}
     * @memberof SummaryClub
     */
    featured?: boolean;
    /**
     * Whether the club is verified or not.
     * @type {boolean}
     * @memberof SummaryClub
     */
    verified?: boolean;
    /**
     * The club's vanity URL.
     * @type {string}
     * @memberof SummaryClub
     */
    url?: string;
}

/**
 * @export
 * @namespace SummaryClub
 */
export namespace SummaryClub {
    /**
     * @export
     * @enum {string}
     */
    export enum SportTypeEnum {
        Cycling = <any> 'cycling',
        Running = <any> 'running',
        Triathlon = <any> 'triathlon',
        Other = <any> 'other'
    }
}

/**
 *
 * @export
 * @interface TemperatureStream
 */
export interface TemperatureStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof TemperatureStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof TemperatureStream
     */
    resolution?: TemperatureStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof TemperatureStream
     */
    series_type?: TemperatureStream.SeriesTypeEnum;
    /**
     * The sequence of temperature values for this stream, in celsius degrees
     * @type {Array&lt;number&gt;}
     * @memberof TemperatureStream
     */
    data?: Array<number>;
}

/**
 * @export
 * @namespace TemperatureStream
 */
export namespace TemperatureStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 *
 * @export
 * @interface TimeStream
 */
export interface TimeStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof TimeStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof TimeStream
     */
    resolution?: TimeStream.ResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof TimeStream
     */
    series_type?: TimeStream.SeriesTypeEnum;
    /**
     * The sequence of time values for this stream, in seconds
     * @type {Array&lt;number&gt;}
     * @memberof TimeStream
     */
    data?: Array<number>;
}

/**
 * @export
 * @namespace TimeStream
 */
export namespace TimeStream {
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}

/**
 * A union type representing the time spent in a given zone.
 * @export
 * @interface TimedZoneRange
 */
export interface TimedZoneRange {
    /**
     * The minimum value in the range.
     * @type {number}
     * @memberof TimedZoneRange
     */
    min?: number;
    /**
     * The maximum value in the range.
     * @type {number}
     * @memberof TimedZoneRange
     */
    max?: number;
    /**
     * The number of seconds spent in this zone
     * @type {number}
     * @memberof TimedZoneRange
     */
    time?: number;
}

/**
 *
 * @export
 * @interface DetailedActivity
 */
export interface DetailedActivity {
    /**
     * The unique identifier of the activity
     * @type {number}
     * @memberof DetailedActivity
     */
    id?: number;
    /**
     * The identifier provided at upload time
     * @type {string}
     * @memberof DetailedActivity
     */
    external_id?: string;
    /**
     * The identifier of the upload that resulted in this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    upload_id?: number;
    /**
     *
     * @type {MetaAthlete}
     * @memberof DetailedActivity
     */
    athlete?: MetaAthlete;
    /**
     * The name of the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    name?: string;
    /**
     * The activity's distance, in meters
     * @type {number}
     * @memberof DetailedActivity
     */
    distance?: number;
    /**
     * The activity's moving time, in seconds
     * @type {number}
     * @memberof DetailedActivity
     */
    moving_time?: number;
    /**
     * The activity's elapsed time, in seconds
     * @type {number}
     * @memberof DetailedActivity
     */
    elapsed_time?: number;
    /**
     * The activity's total elevation gain.
     * @type {number}
     * @memberof DetailedActivity
     */
    total_elevation_gain?: number;
    /**
     * The activity's highest elevation, in meters
     * @type {number}
     * @memberof DetailedActivity
     */
    elev_high?: number;
    /**
     * The activity's lowest elevation, in meters
     * @type {number}
     * @memberof DetailedActivity
     */
    elev_low?: number;
    /**
     *
     * @type {ActivityType}
     * @memberof DetailedActivity
     */
    type?: ActivityType;
    /**
     * The time at which the activity was started.
     * @type {Date}
     * @memberof DetailedActivity
     */
    start_date?: Date;
    /**
     * The time at which the activity was started in the local timezone.
     * @type {Date}
     * @memberof DetailedActivity
     */
    start_date_local?: Date;
    /**
     * The timezone of the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    timezone?: string;
    /**
     *
     * @type {LatLng}
     * @memberof DetailedActivity
     */
    start_latlng?: LatLng;
    /**
     *
     * @type {LatLng}
     * @memberof DetailedActivity
     */
    end_latlng?: LatLng;
    /**
     * The number of achievements gained during this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    achievement_count?: number;
    /**
     * The number of kudos given for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    kudos_count?: number;
    /**
     * The number of comments for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    comment_count?: number;
    /**
     * The number of athletes for taking part in a group activity
     * @type {number}
     * @memberof DetailedActivity
     */
    athlete_count?: number;
    /**
     * The number of Instagram photos for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    photo_count?: number;
    /**
     * The number of Instagram and Strava photos for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    total_photo_count?: number;
    /**
     *
     * @type {PolylineMap}
     * @memberof DetailedActivity
     */
    map?: PolylineMap;
    /**
     * Whether this activity was recorded on a training machine
     * @type {boolean}
     * @memberof DetailedActivity
     */
    trainer?: boolean;
    /**
     * Whether this activity is a commute
     * @type {boolean}
     * @memberof DetailedActivity
     */
    commute?: boolean;
    /**
     * Whether this activity was created manually
     * @type {boolean}
     * @memberof DetailedActivity
     */
    manual?: boolean;
    /**
     * Whether this activity is private
     * @type {boolean}
     * @memberof DetailedActivity
     */
    _private?: boolean;
    /**
     * Whether this activity is flagged
     * @type {boolean}
     * @memberof DetailedActivity
     */
    flagged?: boolean;
    /**
     * The activity's workout type
     * @type {number}
     * @memberof DetailedActivity
     */
    workout_type?: number;
    /**
     * The activity's average speed, in meters per second
     * @type {number}
     * @memberof DetailedActivity
     */
    average_speed?: number;
    /**
     * The activity's max speed, in meters per second
     * @type {number}
     * @memberof DetailedActivity
     */
    max_speed?: number;
    /**
     * Whether the logged-in athlete has kudoed this activity
     * @type {boolean}
     * @memberof DetailedActivity
     */
    has_kudoed?: boolean;
    /**
     * The id of the gear for the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    gear_id?: string;
    /**
     * The total work done in kilojoules during this activity. Rides only
     * @type {number}
     * @memberof DetailedActivity
     */
    kilojoules?: number;
    /**
     * Average power output in watts during this activity. Rides only
     * @type {number}
     * @memberof DetailedActivity
     */
    average_watts?: number;
    /**
     * Whether the watts are from a power meter, false if estimated
     * @type {boolean}
     * @memberof DetailedActivity
     */
    device_watts?: boolean;
    /**
     * Rides with power meter data only
     * @type {number}
     * @memberof DetailedActivity
     */
    max_watts?: number;
    /**
     * Similar to Normalized Power. Rides with power meter data only
     * @type {number}
     * @memberof DetailedActivity
     */
    weighted_average_watts?: number;
    /**
     * The description of the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    description?: string;
    /**
     *
     * @type {PhotosSummary}
     * @memberof DetailedActivity
     */
    photos?: PhotosSummary;
    /**
     *
     * @type {SummaryGear}
     * @memberof DetailedActivity
     */
    gear?: SummaryGear;
    /**
     * The number of kilocalories consumed during this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    calories?: number;
    /**
     *
     * @type {Array&lt;DetailedSegmentEffort&gt;}
     * @memberof DetailedActivity
     */
    segment_efforts?: Array<DetailedSegmentEffort>;
    /**
     * The name of the device used to record the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    device_name?: string;
    /**
     * The token used to embed a Strava activity
     * @type {string}
     * @memberof DetailedActivity
     */
    embed_token?: string;
    /**
     * The splits of this activity in metric units (for runs)
     * @type {Array&lt;Split&gt;}
     * @memberof DetailedActivity
     */
    splits_metric?: Array<Split>;
    /**
     * The splits of this activity in imperial units (for runs)
     * @type {Array&lt;Split&gt;}
     * @memberof DetailedActivity
     */
    splits_standard?: Array<Split>;
    /**
     *
     * @type {Array&lt;Lap&gt;}
     * @memberof DetailedActivity
     */
    laps?: Array<Lap>;
    /**
     *
     * @type {Array&lt;DetailedSegmentEffort&gt;}
     * @memberof DetailedActivity
     */
    best_efforts?: Array<DetailedSegmentEffort>;
}

/**
 *
 * @export
 * @interface DetailedAthlete
 */
export interface DetailedAthlete {
    /**
     * The unique identifier of the athlete
     * @type {number}
     * @memberof DetailedAthlete
     */
    id?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof DetailedAthlete
     */
    resource_state?: number;
    /**
     * The athlete's first name.
     * @type {string}
     * @memberof DetailedAthlete
     */
    firstname?: string;
    /**
     * The athlete's last name.
     * @type {string}
     * @memberof DetailedAthlete
     */
    lastname?: string;
    /**
     * URL to a 62x62 pixel profile picture.
     * @type {string}
     * @memberof DetailedAthlete
     */
    profile_medium?: string;
    /**
     * URL to a 124x124 pixel profile picture.
     * @type {string}
     * @memberof DetailedAthlete
     */
    profile?: string;
    /**
     * The athlete's city.
     * @type {string}
     * @memberof DetailedAthlete
     */
    city?: string;
    /**
     * The athlete's state or geographical region.
     * @type {string}
     * @memberof DetailedAthlete
     */
    state?: string;
    /**
     * The athlete's country.
     * @type {string}
     * @memberof DetailedAthlete
     */
    country?: string;
    /**
     * The athlete's sex.
     * @type {string}
     * @memberof DetailedAthlete
     */
    sex?: DetailedAthlete.SexEnum;
    /**
     * Whether the currently logged-in athlete follows this athlete.
     * @type {string}
     * @memberof DetailedAthlete
     */
    friend?: DetailedAthlete.FriendEnum;
    /**
     * Whether this athlete follows the currently logged-in athlete.
     * @type {string}
     * @memberof DetailedAthlete
     */
    follower?: DetailedAthlete.FollowerEnum;
    /**
     * The athlete's premium status.
     * @type {boolean}
     * @memberof DetailedAthlete
     */
    premium?: boolean;
    /**
     * The time at which the athlete was created.
     * @type {Date}
     * @memberof DetailedAthlete
     */
    created_at?: Date;
    /**
     * The time at which the athlete was last updated.
     * @type {Date}
     * @memberof DetailedAthlete
     */
    updated_at?: Date;
    /**
     * The athlete's follower count.
     * @type {number}
     * @memberof DetailedAthlete
     */
    follower_count?: number;
    /**
     * The athlete's friend count.
     * @type {number}
     * @memberof DetailedAthlete
     */
    friend_count?: number;
    /**
     * The number or athletes mutually followed by this athlete and the currently logged-in athlete.
     * @type {number}
     * @memberof DetailedAthlete
     */
    mutual_friend_count?: number;
    /**
     * The athlete's preferred unit system.
     * @type {string}
     * @memberof DetailedAthlete
     */
    measurement_preference?: DetailedAthlete.MeasurementPreferenceEnum;
    /**
     * The athlete's email address.
     * @type {string}
     * @memberof DetailedAthlete
     */
    email?: string;
    /**
     * The athlete's FTP (Functional Threshold Power).
     * @type {number}
     * @memberof DetailedAthlete
     */
    ftp?: number;
    /**
     * The athlete's weight.
     * @type {number}
     * @memberof DetailedAthlete
     */
    weight?: number;
    /**
     * The athlete's clubs.
     * @type {Array&lt;SummaryClub&gt;}
     * @memberof DetailedAthlete
     */
    clubs?: Array<SummaryClub>;
    /**
     * The athlete's bikes.
     * @type {Array&lt;SummaryGear&gt;}
     * @memberof DetailedAthlete
     */
    bikes?: Array<SummaryGear>;
    /**
     * The athlete's shoes.
     * @type {Array&lt;SummaryGear&gt;}
     * @memberof DetailedAthlete
     */
    shoes?: Array<SummaryGear>;
}

/**
 * @export
 * @namespace DetailedAthlete
 */
export namespace DetailedAthlete {
    /**
     * @export
     * @enum {string}
     */
    export enum SexEnum {
        M = <any> 'M',
        F = <any> 'F'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FriendEnum {
        Pending = <any> 'pending',
        Accepted = <any> 'accepted',
        Blocked = <any> 'blocked'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FollowerEnum {
        Pending = <any> 'pending',
        Accepted = <any> 'accepted',
        Blocked = <any> 'blocked'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MeasurementPreferenceEnum {
        Feet = <any> 'feet',
        Meters = <any> 'meters'
    }
}

/**
 *
 * @export
 * @interface DetailedClub
 */
export interface DetailedClub {
    /**
     * The club's unique identifier.
     * @type {number}
     * @memberof DetailedClub
     */
    id?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof DetailedClub
     */
    resource_state?: number;
    /**
     * The club's name.
     * @type {string}
     * @memberof DetailedClub
     */
    name?: string;
    /**
     * URL to a 60x60 pixel profile picture.
     * @type {string}
     * @memberof DetailedClub
     */
    profile_medium?: string;
    /**
     * URL to a ~1185x580 pixel cover photo.
     * @type {string}
     * @memberof DetailedClub
     */
    cover_photo?: string;
    /**
     * URL to a ~360x176  pixel cover photo.
     * @type {string}
     * @memberof DetailedClub
     */
    cover_photo_small?: string;
    /**
     *
     * @type {string}
     * @memberof DetailedClub
     */
    sport_type?: DetailedClub.SportTypeEnum;
    /**
     * The club's city.
     * @type {string}
     * @memberof DetailedClub
     */
    city?: string;
    /**
     * The club's state or geographical region.
     * @type {string}
     * @memberof DetailedClub
     */
    state?: string;
    /**
     * The club's country.
     * @type {string}
     * @memberof DetailedClub
     */
    country?: string;
    /**
     * Whether the club is private.
     * @type {boolean}
     * @memberof DetailedClub
     */
    _private?: boolean;
    /**
     * The club's member count.
     * @type {number}
     * @memberof DetailedClub
     */
    member_count?: number;
    /**
     * Whether the club is featured or not.
     * @type {boolean}
     * @memberof DetailedClub
     */
    featured?: boolean;
    /**
     * Whether the club is verified or not.
     * @type {boolean}
     * @memberof DetailedClub
     */
    verified?: boolean;
    /**
     * The club's vanity URL.
     * @type {string}
     * @memberof DetailedClub
     */
    url?: string;
    /**
     * The membership status of the logged-in athlete.
     * @type {string}
     * @memberof DetailedClub
     */
    membership?: DetailedClub.MembershipEnum;
    /**
     * Whether the currently logged-in athlete is an administrator of this club.
     * @type {boolean}
     * @memberof DetailedClub
     */
    admin?: boolean;
    /**
     * Whether the currently logged-in athlete is the owner of this club.
     * @type {boolean}
     * @memberof DetailedClub
     */
    owner?: boolean;
    /**
     * The number of athletes in the club that the logged-in athlete follows.
     * @type {number}
     * @memberof DetailedClub
     */
    following_count?: number;
}

/**
 * @export
 * @namespace DetailedClub
 */
export namespace DetailedClub {
    /**
     * @export
     * @enum {string}
     */
    export enum SportTypeEnum {
        Cycling = <any> 'cycling',
        Running = <any> 'running',
        Triathlon = <any> 'triathlon',
        Other = <any> 'other'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MembershipEnum {
        Member = <any> 'member',
        Pending = <any> 'pending'
    }
}

/**
 * ActivitiesApi - fetch parameter creator
 * @export
 */
export const ActivitiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a manual activity for an athlete. Requires write permissions, as requested during the authorization process.
         * @summary Create an Activity
         * @param {string} name The name of the activity.
         * @param {string} type Type of activity. For example - Run, Ride etc.
         * @param {string} startDateLocal ISO 8601 formatted date time.
         * @param {number} elapsedTime In seconds.
         * @param {string} [description] Description of the activity.
         * @param {string} [distance] In meters.
         * @param {number} [_private] set to 1 to mark the resulting activity as private, ‘view_private’ permissions will be necessary to view the activity. If not specified, set according to the athlete’s privacy setting (recommended).
         * @param {number} [trainer] Set to 1 to mark as a trainer activity.
         * @param {string} [photoIds] List of native photo ids to attach to the activity.
         * @param {number} [commute] Set to 1 to mark as commute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity(name: string, type: string, startDateLocal: string, elapsedTime: number, description?: string, distance?: string, _private?: number, trainer?: number, photoIds?: string, commute?: number, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createActivity.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling createActivity.');
            }
            // verify required parameter 'startDateLocal' is not null or undefined
            if (startDateLocal === null || startDateLocal === undefined) {
                throw new RequiredError('startDateLocal','Required parameter startDateLocal was null or undefined when calling createActivity.');
            }
            // verify required parameter 'elapsedTime' is not null or undefined
            if (elapsedTime === null || elapsedTime === undefined) {
                throw new RequiredError('elapsedTime','Required parameter elapsedTime was null or undefined when calling createActivity.');
            }
            const localVarPath = `/activities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (type !== undefined) {
                localVarFormParams.set('type', type as any);
            }

            if (startDateLocal !== undefined) {
                localVarFormParams.set('start_date_local', startDateLocal as any);
            }

            if (elapsedTime !== undefined) {
                localVarFormParams.set('elapsed_time', elapsedTime as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('description', description as any);
            }

            if (distance !== undefined) {
                localVarFormParams.set('distance', distance as any);
            }

            if (_private !== undefined) {
                localVarFormParams.set('private', _private as any);
            }

            if (trainer !== undefined) {
                localVarFormParams.set('trainer', trainer as any);
            }

            if (photoIds !== undefined) {
                localVarFormParams.set('photo_ids', photoIds as any);
            }

            if (commute !== undefined) {
                localVarFormParams.set('commute', commute as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the given activity that is owned by the authenticated athlete.
         * @summary Get Activity
         * @param {number} id The identifier of the activity.
         * @param {boolean} [includeAllEfforts] To include all segments efforts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityById(id: number, includeAllEfforts?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getActivityById.');
            }
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (includeAllEfforts !== undefined) {
                localVarQueryParameter['include_all_efforts'] = includeAllEfforts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the comments on the given activity.
         * @summary List Activity Comments
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByActivityId(id: number, page?: number, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCommentsByActivityId.');
            }
            const localVarPath = `/activities/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the athletes who kudoed an activity identified by an identifier.
         * @summary List Activity Kudoers
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKudoersByActivityId(id: number, page?: number, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKudoersByActivityId.');
            }
            const localVarPath = `/activities/{id}/kudos`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the laps of an activity identified by an identifier.
         * @summary List Activity Laps
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLapsByActivityId(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLapsByActivityId.');
            }
            const localVarPath = `/activities/{id}/laps`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the activities of an athlete for a specific identifier.
         * @summary List Athlete Activities
         * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
         * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteActivities(before?: number, after?: number, page?: number, perPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/athlete/activities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium Feature. Returns the zones of a given activity.
         * @summary Get Activity Zones
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZonesByActivityId(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getZonesByActivityId.');
            }
            const localVarPath = `/activities/{id}/zones`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given activity that is owned by the authenticated athlete.
         * @summary Update Activity
         * @param {number} id The identifier of the activity.
         * @param {UpdatableActivity} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityById(id: number, body?: UpdatableActivity, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateActivityById.');
            }
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatableActivity" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a manual activity for an athlete. Requires write permissions, as requested during the authorization process.
         * @summary Create an Activity
         * @param {string} name The name of the activity.
         * @param {string} type Type of activity. For example - Run, Ride etc.
         * @param {string} startDateLocal ISO 8601 formatted date time.
         * @param {number} elapsedTime In seconds.
         * @param {string} [description] Description of the activity.
         * @param {string} [distance] In meters.
         * @param {number} [_private] set to 1 to mark the resulting activity as private, ‘view_private’ permissions will be necessary to view the activity. If not specified, set according to the athlete’s privacy setting (recommended).
         * @param {number} [trainer] Set to 1 to mark as a trainer activity.
         * @param {string} [photoIds] List of native photo ids to attach to the activity.
         * @param {number} [commute] Set to 1 to mark as commute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity(name: string, type: string, startDateLocal: string, elapsedTime: number, description?: string, distance?: string, _private?: number, trainer?: number, photoIds?: string, commute?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedActivity> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).createActivity(name, type, startDateLocal, elapsedTime, description, distance, _private, trainer, photoIds, commute, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the given activity that is owned by the authenticated athlete.
         * @summary Get Activity
         * @param {number} id The identifier of the activity.
         * @param {boolean} [includeAllEfforts] To include all segments efforts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityById(id: number, includeAllEfforts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedActivity> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).getActivityById(id, includeAllEfforts, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the comments on the given activity.
         * @summary List Activity Comments
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByActivityId(id: number, page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Comment>> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).getCommentsByActivityId(id, page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the athletes who kudoed an activity identified by an identifier.
         * @summary List Activity Kudoers
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKudoersByActivityId(id: number, page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryAthlete>> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).getKudoersByActivityId(id, page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the laps of an activity identified by an identifier.
         * @summary List Activity Laps
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLapsByActivityId(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Lap>> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).getLapsByActivityId(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the activities of an athlete for a specific identifier.
         * @summary List Athlete Activities
         * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
         * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteActivities(before?: number, after?: number, page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryActivity>> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).getLoggedInAthleteActivities(before, after, page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Premium Feature. Returns the zones of a given activity.
         * @summary Get Activity Zones
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZonesByActivityId(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ActivityZone>> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).getZonesByActivityId(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the given activity that is owned by the authenticated athlete.
         * @summary Update Activity
         * @param {number} id The identifier of the activity.
         * @param {UpdatableActivity} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityById(id: number, body?: UpdatableActivity, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedActivity> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).updateActivityById(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a manual activity for an athlete. Requires write permissions, as requested during the authorization process.
         * @summary Create an Activity
         * @param {string} name The name of the activity.
         * @param {string} type Type of activity. For example - Run, Ride etc.
         * @param {string} startDateLocal ISO 8601 formatted date time.
         * @param {number} elapsedTime In seconds.
         * @param {string} [description] Description of the activity.
         * @param {string} [distance] In meters.
         * @param {number} [_private] set to 1 to mark the resulting activity as private, ‘view_private’ permissions will be necessary to view the activity. If not specified, set according to the athlete’s privacy setting (recommended).
         * @param {number} [trainer] Set to 1 to mark as a trainer activity.
         * @param {string} [photoIds] List of native photo ids to attach to the activity.
         * @param {number} [commute] Set to 1 to mark as commute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity(name: string, type: string, startDateLocal: string, elapsedTime: number, description?: string, distance?: string, _private?: number, trainer?: number, photoIds?: string, commute?: number, options?: any) {
            return ActivitiesApiFp(configuration).createActivity(name, type, startDateLocal, elapsedTime, description, distance, _private, trainer, photoIds, commute, options)(fetch, basePath);
        },
        /**
         * Returns the given activity that is owned by the authenticated athlete.
         * @summary Get Activity
         * @param {number} id The identifier of the activity.
         * @param {boolean} [includeAllEfforts] To include all segments efforts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityById(id: number, includeAllEfforts?: boolean, options?: any) {
            return ActivitiesApiFp(configuration).getActivityById(id, includeAllEfforts, options)(fetch, basePath);
        },
        /**
         * Returns the comments on the given activity.
         * @summary List Activity Comments
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByActivityId(id: number, page?: number, perPage?: number, options?: any) {
            return ActivitiesApiFp(configuration).getCommentsByActivityId(id, page, perPage, options)(fetch, basePath);
        },
        /**
         * Returns the athletes who kudoed an activity identified by an identifier.
         * @summary List Activity Kudoers
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKudoersByActivityId(id: number, page?: number, perPage?: number, options?: any) {
            return ActivitiesApiFp(configuration).getKudoersByActivityId(id, page, perPage, options)(fetch, basePath);
        },
        /**
         * Returns the laps of an activity identified by an identifier.
         * @summary List Activity Laps
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLapsByActivityId(id: number, options?: any) {
            return ActivitiesApiFp(configuration).getLapsByActivityId(id, options)(fetch, basePath);
        },
        /**
         * Returns the activities of an athlete for a specific identifier.
         * @summary List Athlete Activities
         * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
         * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteActivities(before?: number, after?: number, page?: number, perPage?: number, options?: any) {
            return ActivitiesApiFp(configuration).getLoggedInAthleteActivities(before, after, page, perPage, options)(fetch, basePath);
        },
        /**
         * Premium Feature. Returns the zones of a given activity.
         * @summary Get Activity Zones
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZonesByActivityId(id: number, options?: any) {
            return ActivitiesApiFp(configuration).getZonesByActivityId(id, options)(fetch, basePath);
        },
        /**
         * Updates the given activity that is owned by the authenticated athlete.
         * @summary Update Activity
         * @param {number} id The identifier of the activity.
         * @param {UpdatableActivity} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityById(id: number, body?: UpdatableActivity, options?: any) {
            return ActivitiesApiFp(configuration).updateActivityById(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * Creates a manual activity for an athlete. Requires write permissions, as requested during the authorization process.
     * @summary Create an Activity
     * @param {} name The name of the activity.
     * @param {} type Type of activity. For example - Run, Ride etc.
     * @param {} startDateLocal ISO 8601 formatted date time.
     * @param {} elapsedTime In seconds.
     * @param {} [description] Description of the activity.
     * @param {} [distance] In meters.
     * @param {} [_private] set to 1 to mark the resulting activity as private, ‘view_private’ permissions will be necessary to view the activity. If not specified, set according to the athlete’s privacy setting (recommended).
     * @param {} [trainer] Set to 1 to mark as a trainer activity.
     * @param {} [photoIds] List of native photo ids to attach to the activity.
     * @param {} [commute] Set to 1 to mark as commute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public createActivity(name: string, type: string, startDateLocal: string, elapsedTime: number, description?: string, distance?: string, _private?: number, trainer?: number, photoIds?: string, commute?: number, options?: any) {
        return ActivitiesApiFp(this.configuration).createActivity(name, type, startDateLocal, elapsedTime, description, distance, _private, trainer, photoIds, commute, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the given activity that is owned by the authenticated athlete.
     * @summary Get Activity
     * @param {} id The identifier of the activity.
     * @param {} [includeAllEfforts] To include all segments efforts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getActivityById(id: number, includeAllEfforts?: boolean, options?: any) {
        return ActivitiesApiFp(this.configuration).getActivityById(id, includeAllEfforts, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the comments on the given activity.
     * @summary List Activity Comments
     * @param {} id The identifier of the activity.
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getCommentsByActivityId(id: number, page?: number, perPage?: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getCommentsByActivityId(id, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the athletes who kudoed an activity identified by an identifier.
     * @summary List Activity Kudoers
     * @param {} id The identifier of the activity.
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getKudoersByActivityId(id: number, page?: number, perPage?: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getKudoersByActivityId(id, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the laps of an activity identified by an identifier.
     * @summary List Activity Laps
     * @param {} id The identifier of the activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getLapsByActivityId(id: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getLapsByActivityId(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the activities of an athlete for a specific identifier.
     * @summary List Athlete Activities
     * @param {} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
     * @param {} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getLoggedInAthleteActivities(before?: number, after?: number, page?: number, perPage?: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getLoggedInAthleteActivities(before, after, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Premium Feature. Returns the zones of a given activity.
     * @summary Get Activity Zones
     * @param {} id The identifier of the activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getZonesByActivityId(id: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getZonesByActivityId(id, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the given activity that is owned by the authenticated athlete.
     * @summary Update Activity
     * @param {} id The identifier of the activity.
     * @param {} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public updateActivityById(id: number, body?: UpdatableActivity, options?: any) {
        return ActivitiesApiFp(this.configuration).updateActivityById(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * AthletesApi - fetch parameter creator
 * @export
 */
export const AthletesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the currently authenticated athlete.
         * @summary Get Authenticated Athlete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthlete(options: any = {}): FetchArgs {
            const localVarPath = `/athlete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the the authenticated athlete's heart rate and power zones.
         * @summary Get Zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteZones(options: any = {}): FetchArgs {
            const localVarPath = `/athlete/zones`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the activity stats of an athlete.
         * @summary Get Athlete Stats
         * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(id: number, page?: number, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStats.');
            }
            const localVarPath = `/athletes/{id}/stats`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the currently authenticated athlete.
         * @summary Update Athlete
         * @param {DetailedAthlete} body The athlete entity to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoggedInAthlete(body: DetailedAthlete, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateLoggedInAthlete.');
            }
            const localVarPath = `/athlete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DetailedAthlete" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AthletesApi - functional programming interface
 * @export
 */
export const AthletesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the currently authenticated athlete.
         * @summary Get Authenticated Athlete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthlete(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedAthlete> {
            const localVarFetchArgs = AthletesApiFetchParamCreator(configuration).getLoggedInAthlete(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the the authenticated athlete's heart rate and power zones.
         * @summary Get Zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteZones(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Zones> {
            const localVarFetchArgs = AthletesApiFetchParamCreator(configuration).getLoggedInAthleteZones(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the activity stats of an athlete.
         * @summary Get Athlete Stats
         * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(id: number, page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityStats> {
            const localVarFetchArgs = AthletesApiFetchParamCreator(configuration).getStats(id, page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the currently authenticated athlete.
         * @summary Update Athlete
         * @param {DetailedAthlete} body The athlete entity to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoggedInAthlete(body: DetailedAthlete, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedAthlete> {
            const localVarFetchArgs = AthletesApiFetchParamCreator(configuration).updateLoggedInAthlete(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AthletesApi - factory interface
 * @export
 */
export const AthletesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the currently authenticated athlete.
         * @summary Get Authenticated Athlete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthlete(options?: any) {
            return AthletesApiFp(configuration).getLoggedInAthlete(options)(fetch, basePath);
        },
        /**
         * Returns the the authenticated athlete's heart rate and power zones.
         * @summary Get Zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteZones(options?: any) {
            return AthletesApiFp(configuration).getLoggedInAthleteZones(options)(fetch, basePath);
        },
        /**
         * Returns the activity stats of an athlete.
         * @summary Get Athlete Stats
         * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(id: number, page?: number, perPage?: number, options?: any) {
            return AthletesApiFp(configuration).getStats(id, page, perPage, options)(fetch, basePath);
        },
        /**
         * Update the currently authenticated athlete.
         * @summary Update Athlete
         * @param {DetailedAthlete} body The athlete entity to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoggedInAthlete(body: DetailedAthlete, options?: any) {
            return AthletesApiFp(configuration).updateLoggedInAthlete(body, options)(fetch, basePath);
        },
    };
};

/**
 * AthletesApi - object-oriented interface
 * @export
 * @class AthletesApi
 * @extends {BaseAPI}
 */
export class AthletesApi extends BaseAPI {
    /**
     * Returns the currently authenticated athlete.
     * @summary Get Authenticated Athlete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AthletesApi
     */
    public getLoggedInAthlete(options?: any) {
        return AthletesApiFp(this.configuration).getLoggedInAthlete(options)(this.fetch, this.basePath);
    }

    /**
     * Returns the the authenticated athlete's heart rate and power zones.
     * @summary Get Zones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AthletesApi
     */
    public getLoggedInAthleteZones(options?: any) {
        return AthletesApiFp(this.configuration).getLoggedInAthleteZones(options)(this.fetch, this.basePath);
    }

    /**
     * Returns the activity stats of an athlete.
     * @summary Get Athlete Stats
     * @param {} id The identifier of the athlete. Must match the authenticated athlete.
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AthletesApi
     */
    public getStats(id: number, page?: number, perPage?: number, options?: any) {
        return AthletesApiFp(this.configuration).getStats(id, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Update the currently authenticated athlete.
     * @summary Update Athlete
     * @param {} body The athlete entity to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AthletesApi
     */
    public updateLoggedInAthlete(body: DetailedAthlete, options?: any) {
        return AthletesApiFp(this.configuration).updateLoggedInAthlete(body, options)(this.fetch, this.basePath);
    }

}

/**
 * ClubsApi - fetch parameter creator
 * @export
 */
export const ClubsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Enhanced Privacy Mode is respected for all activities.
         * @summary List Club Activities
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubActivitiesById(id: number, page?: number, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getClubActivitiesById.');
            }
            const localVarPath = `/clubs/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the administrators of a given club.
         * @summary List Club Administrators.
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubAdminsById(id: number, page?: number, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getClubAdminsById.');
            }
            const localVarPath = `/clubs/{id}/admins`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a given club using its identifier.
         * @summary Get Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getClubById.');
            }
            const localVarPath = `/clubs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the athletes who are members of a given club.
         * @summary List Club Members
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubMembersById(id: number, page?: number, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getClubMembersById.');
            }
            const localVarPath = `/clubs/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the clubs whose membership includes the authenticated athlete.
         * @summary List Athlete Clubs
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteClubs(page?: number, perPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/athlete/clubs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds the authenticated athlete to the club's membership.
         * @summary Join Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinClubById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling joinClubById.');
            }
            const localVarPath = `/clubs/{id}/join`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the authenticated athlete from the club's membership.
         * @summary Leave Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveClubById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling leaveClubById.');
            }
            const localVarPath = `/clubs/{id}/leave`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClubsApi - functional programming interface
 * @export
 */
export const ClubsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Enhanced Privacy Mode is respected for all activities.
         * @summary List Club Activities
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubActivitiesById(id: number, page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryActivity>> {
            const localVarFetchArgs = ClubsApiFetchParamCreator(configuration).getClubActivitiesById(id, page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of the administrators of a given club.
         * @summary List Club Administrators.
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubAdminsById(id: number, page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryAthlete>> {
            const localVarFetchArgs = ClubsApiFetchParamCreator(configuration).getClubAdminsById(id, page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a given club using its identifier.
         * @summary Get Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedClub> {
            const localVarFetchArgs = ClubsApiFetchParamCreator(configuration).getClubById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of the athletes who are members of a given club.
         * @summary List Club Members
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubMembersById(id: number, page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryAthlete>> {
            const localVarFetchArgs = ClubsApiFetchParamCreator(configuration).getClubMembersById(id, page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of the clubs whose membership includes the authenticated athlete.
         * @summary List Athlete Clubs
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteClubs(page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryClub>> {
            const localVarFetchArgs = ClubsApiFetchParamCreator(configuration).getLoggedInAthleteClubs(page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds the authenticated athlete to the club's membership.
         * @summary Join Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinClubById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MembershipApplication> {
            const localVarFetchArgs = ClubsApiFetchParamCreator(configuration).joinClubById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes the authenticated athlete from the club's membership.
         * @summary Leave Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveClubById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MembershipApplication> {
            const localVarFetchArgs = ClubsApiFetchParamCreator(configuration).leaveClubById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClubsApi - factory interface
 * @export
 */
export const ClubsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Enhanced Privacy Mode is respected for all activities.
         * @summary List Club Activities
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubActivitiesById(id: number, page?: number, perPage?: number, options?: any) {
            return ClubsApiFp(configuration).getClubActivitiesById(id, page, perPage, options)(fetch, basePath);
        },
        /**
         * Returns a list of the administrators of a given club.
         * @summary List Club Administrators.
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubAdminsById(id: number, page?: number, perPage?: number, options?: any) {
            return ClubsApiFp(configuration).getClubAdminsById(id, page, perPage, options)(fetch, basePath);
        },
        /**
         * Returns a given club using its identifier.
         * @summary Get Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubById(id: number, options?: any) {
            return ClubsApiFp(configuration).getClubById(id, options)(fetch, basePath);
        },
        /**
         * Returns a list of the athletes who are members of a given club.
         * @summary List Club Members
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubMembersById(id: number, page?: number, perPage?: number, options?: any) {
            return ClubsApiFp(configuration).getClubMembersById(id, page, perPage, options)(fetch, basePath);
        },
        /**
         * Returns a list of the clubs whose membership includes the authenticated athlete.
         * @summary List Athlete Clubs
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteClubs(page?: number, perPage?: number, options?: any) {
            return ClubsApiFp(configuration).getLoggedInAthleteClubs(page, perPage, options)(fetch, basePath);
        },
        /**
         * Adds the authenticated athlete to the club's membership.
         * @summary Join Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinClubById(id: number, options?: any) {
            return ClubsApiFp(configuration).joinClubById(id, options)(fetch, basePath);
        },
        /**
         * Removes the authenticated athlete from the club's membership.
         * @summary Leave Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveClubById(id: number, options?: any) {
            return ClubsApiFp(configuration).leaveClubById(id, options)(fetch, basePath);
        },
    };
};

/**
 * ClubsApi - object-oriented interface
 * @export
 * @class ClubsApi
 * @extends {BaseAPI}
 */
export class ClubsApi extends BaseAPI {
    /**
     * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Enhanced Privacy Mode is respected for all activities.
     * @summary List Club Activities
     * @param {} id The identifier of the club.
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public getClubActivitiesById(id: number, page?: number, perPage?: number, options?: any) {
        return ClubsApiFp(this.configuration).getClubActivitiesById(id, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of the administrators of a given club.
     * @summary List Club Administrators.
     * @param {} id The identifier of the club.
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public getClubAdminsById(id: number, page?: number, perPage?: number, options?: any) {
        return ClubsApiFp(this.configuration).getClubAdminsById(id, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a given club using its identifier.
     * @summary Get Club
     * @param {} id The identifier of the club.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public getClubById(id: number, options?: any) {
        return ClubsApiFp(this.configuration).getClubById(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of the athletes who are members of a given club.
     * @summary List Club Members
     * @param {} id The identifier of the club.
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public getClubMembersById(id: number, page?: number, perPage?: number, options?: any) {
        return ClubsApiFp(this.configuration).getClubMembersById(id, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of the clubs whose membership includes the authenticated athlete.
     * @summary List Athlete Clubs
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public getLoggedInAthleteClubs(page?: number, perPage?: number, options?: any) {
        return ClubsApiFp(this.configuration).getLoggedInAthleteClubs(page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Adds the authenticated athlete to the club's membership.
     * @summary Join Club
     * @param {} id The identifier of the club.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public joinClubById(id: number, options?: any) {
        return ClubsApiFp(this.configuration).joinClubById(id, options)(this.fetch, this.basePath);
    }

    /**
     * Removes the authenticated athlete from the club's membership.
     * @summary Leave Club
     * @param {} id The identifier of the club.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public leaveClubById(id: number, options?: any) {
        return ClubsApiFp(this.configuration).leaveClubById(id, options)(this.fetch, this.basePath);
    }

}

/**
 * GearsApi - fetch parameter creator
 * @export
 */
export const GearsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an equipment using its identifier.
         * @summary Get Equipment
         * @param {number} id The identifier of the gear.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGearById.');
            }
            const localVarPath = `/gear/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GearsApi - functional programming interface
 * @export
 */
export const GearsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns an equipment using its identifier.
         * @summary Get Equipment
         * @param {number} id The identifier of the gear.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedGear> {
            const localVarFetchArgs = GearsApiFetchParamCreator(configuration).getGearById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GearsApi - factory interface
 * @export
 */
export const GearsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns an equipment using its identifier.
         * @summary Get Equipment
         * @param {number} id The identifier of the gear.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearById(id: number, options?: any) {
            return GearsApiFp(configuration).getGearById(id, options)(fetch, basePath);
        },
    };
};

/**
 * GearsApi - object-oriented interface
 * @export
 * @class GearsApi
 * @extends {BaseAPI}
 */
export class GearsApi extends BaseAPI {
    /**
     * Returns an equipment using its identifier.
     * @summary Get Equipment
     * @param {} id The identifier of the gear.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GearsApi
     */
    public getGearById(id: number, options?: any) {
        return GearsApiFp(this.configuration).getGearById(id, options)(this.fetch, this.basePath);
    }

}

/**
 * RoutesApi - fetch parameter creator
 * @export
 */
export const RoutesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a route using its identifier.
         * @summary Get Route
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRouteById.');
            }
            const localVarPath = `/routes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the routes created by the authenticated athlete using their athlete ID.
         * @summary List Athlete Routes
         * @param {number} id The identifier of the athlete.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesByAthleteId(id: number, page?: number, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRoutesByAthleteId.');
            }
            const localVarPath = `/athletes/{id}/routes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutesApi - functional programming interface
 * @export
 */
export const RoutesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a route using its identifier.
         * @summary Get Route
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Route> {
            const localVarFetchArgs = RoutesApiFetchParamCreator(configuration).getRouteById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of the routes created by the authenticated athlete using their athlete ID.
         * @summary List Athlete Routes
         * @param {number} id The identifier of the athlete.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesByAthleteId(id: number, page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Route>> {
            const localVarFetchArgs = RoutesApiFetchParamCreator(configuration).getRoutesByAthleteId(id, page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RoutesApi - factory interface
 * @export
 */
export const RoutesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a route using its identifier.
         * @summary Get Route
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteById(id: number, options?: any) {
            return RoutesApiFp(configuration).getRouteById(id, options)(fetch, basePath);
        },
        /**
         * Returns a list of the routes created by the authenticated athlete using their athlete ID.
         * @summary List Athlete Routes
         * @param {number} id The identifier of the athlete.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesByAthleteId(id: number, page?: number, perPage?: number, options?: any) {
            return RoutesApiFp(configuration).getRoutesByAthleteId(id, page, perPage, options)(fetch, basePath);
        },
    };
};

/**
 * RoutesApi - object-oriented interface
 * @export
 * @class RoutesApi
 * @extends {BaseAPI}
 */
export class RoutesApi extends BaseAPI {
    /**
     * Returns a route using its identifier.
     * @summary Get Route
     * @param {} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public getRouteById(id: number, options?: any) {
        return RoutesApiFp(this.configuration).getRouteById(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of the routes created by the authenticated athlete using their athlete ID.
     * @summary List Athlete Routes
     * @param {} id The identifier of the athlete.
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public getRoutesByAthleteId(id: number, page?: number, perPage?: number, options?: any) {
        return RoutesApiFp(this.configuration).getRoutesByAthleteId(id, page, perPage, options)(this.fetch, this.basePath);
    }

}

/**
 * RunningRacesApi - fetch parameter creator
 * @export
 */
export const RunningRacesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a running race for a given identifier.
         * @summary Get Running Race
         * @param {number} id The identifier of the running race.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningRaceById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRunningRaceById.');
            }
            const localVarPath = `/running_races/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list running races based on a set of search criteria.
         * @summary List Running Races
         * @param {number} [year] Filters the list by a given year.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningRaces(year?: number, options: any = {}): FetchArgs {
            const localVarPath = `/running_races`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunningRacesApi - functional programming interface
 * @export
 */
export const RunningRacesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a running race for a given identifier.
         * @summary Get Running Race
         * @param {number} id The identifier of the running race.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningRaceById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RunningRace> {
            const localVarFetchArgs = RunningRacesApiFetchParamCreator(configuration).getRunningRaceById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list running races based on a set of search criteria.
         * @summary List Running Races
         * @param {number} [year] Filters the list by a given year.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningRaces(year?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RunningRace>> {
            const localVarFetchArgs = RunningRacesApiFetchParamCreator(configuration).getRunningRaces(year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunningRacesApi - factory interface
 * @export
 */
export const RunningRacesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a running race for a given identifier.
         * @summary Get Running Race
         * @param {number} id The identifier of the running race.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningRaceById(id: number, options?: any) {
            return RunningRacesApiFp(configuration).getRunningRaceById(id, options)(fetch, basePath);
        },
        /**
         * Returns a list running races based on a set of search criteria.
         * @summary List Running Races
         * @param {number} [year] Filters the list by a given year.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningRaces(year?: number, options?: any) {
            return RunningRacesApiFp(configuration).getRunningRaces(year, options)(fetch, basePath);
        },
    };
};

/**
 * RunningRacesApi - object-oriented interface
 * @export
 * @class RunningRacesApi
 * @extends {BaseAPI}
 */
export class RunningRacesApi extends BaseAPI {
    /**
     * Returns a running race for a given identifier.
     * @summary Get Running Race
     * @param {} id The identifier of the running race.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunningRacesApi
     */
    public getRunningRaceById(id: number, options?: any) {
        return RunningRacesApiFp(this.configuration).getRunningRaceById(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list running races based on a set of search criteria.
     * @summary List Running Races
     * @param {} [year] Filters the list by a given year.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunningRacesApi
     */
    public getRunningRaces(year?: number, options?: any) {
        return RunningRacesApiFp(this.configuration).getRunningRaces(year, options)(this.fetch, this.basePath);
    }

}

/**
 * SegmentEffortsApi - fetch parameter creator
 * @export
 */
export const SegmentEffortsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a set of the authenticated athlete's segment efforts for a given segment.
         * @summary List Segment Efforts
         * @param {number} id The identifier of the segment.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffortsBySegmentId(id: number, page?: number, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getEffortsBySegmentId.');
            }
            const localVarPath = `/segments/{id}/all_efforts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a segment effort from an activity that is owned by the authenticated athlete.
         * @summary Get Segment Effort
         * @param {number} id The identifier of the segment effort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentEffortById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSegmentEffortById.');
            }
            const localVarPath = `/segment_efforts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentEffortsApi - functional programming interface
 * @export
 */
export const SegmentEffortsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a set of the authenticated athlete's segment efforts for a given segment.
         * @summary List Segment Efforts
         * @param {number} id The identifier of the segment.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffortsBySegmentId(id: number, page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DetailedSegmentEffort>> {
            const localVarFetchArgs = SegmentEffortsApiFetchParamCreator(configuration).getEffortsBySegmentId(id, page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a segment effort from an activity that is owned by the authenticated athlete.
         * @summary Get Segment Effort
         * @param {number} id The identifier of the segment effort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentEffortById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedSegmentEffort> {
            const localVarFetchArgs = SegmentEffortsApiFetchParamCreator(configuration).getSegmentEffortById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SegmentEffortsApi - factory interface
 * @export
 */
export const SegmentEffortsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a set of the authenticated athlete's segment efforts for a given segment.
         * @summary List Segment Efforts
         * @param {number} id The identifier of the segment.
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffortsBySegmentId(id: number, page?: number, perPage?: number, options?: any) {
            return SegmentEffortsApiFp(configuration).getEffortsBySegmentId(id, page, perPage, options)(fetch, basePath);
        },
        /**
         * Returns a segment effort from an activity that is owned by the authenticated athlete.
         * @summary Get Segment Effort
         * @param {number} id The identifier of the segment effort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentEffortById(id: number, options?: any) {
            return SegmentEffortsApiFp(configuration).getSegmentEffortById(id, options)(fetch, basePath);
        },
    };
};

/**
 * SegmentEffortsApi - object-oriented interface
 * @export
 * @class SegmentEffortsApi
 * @extends {BaseAPI}
 */
export class SegmentEffortsApi extends BaseAPI {
    /**
     * Returns a set of the authenticated athlete's segment efforts for a given segment.
     * @summary List Segment Efforts
     * @param {} id The identifier of the segment.
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentEffortsApi
     */
    public getEffortsBySegmentId(id: number, page?: number, perPage?: number, options?: any) {
        return SegmentEffortsApiFp(this.configuration).getEffortsBySegmentId(id, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a segment effort from an activity that is owned by the authenticated athlete.
     * @summary Get Segment Effort
     * @param {} id The identifier of the segment effort.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentEffortsApi
     */
    public getSegmentEffortById(id: number, options?: any) {
        return SegmentEffortsApiFp(this.configuration).getSegmentEffortById(id, options)(this.fetch, this.basePath);
    }

}

/**
 * SegmentsApi - fetch parameter creator
 * @export
 */
export const SegmentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the top 10 segments matching a specified query.
         * @summary Explore segments
         * @param {Array&lt;number&gt;} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
         * @param {string} [activityType] Desired activity type.
         * @param {number} [minCat] The minimum climbing category.
         * @param {number} [maxCat] The maximum climbing category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreSegments(bounds: Array<number>, activityType?: string, minCat?: number, maxCat?: number, options: any = {}): FetchArgs {
            // verify required parameter 'bounds' is not null or undefined
            if (bounds === null || bounds === undefined) {
                throw new RequiredError('bounds','Required parameter bounds was null or undefined when calling exploreSegments.');
            }
            const localVarPath = `/segments/explore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (bounds) {
                localVarQueryParameter['bounds'] = bounds.join(COLLECTION_FORMATS["csv"]);
            }

            if (activityType !== undefined) {
                localVarQueryParameter['activity_type'] = activityType;
            }

            if (minCat !== undefined) {
                localVarQueryParameter['min_cat'] = minCat;
            }

            if (maxCat !== undefined) {
                localVarQueryParameter['max_cat'] = maxCat;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified segment leaderboard.
         * @summary Get Segment Leaderboard
         * @param {number} id The identifier of the segment leaderboard.
         * @param {string} [gender] Filter by gender.
         * @param {string} [ageGroup] Premium Feature. Filter by age group.
         * @param {string} [weightClass] Premium Feature. Filter by weight class.
         * @param {boolean} [following] Filter by friends of the authenticated athlete.
         * @param {number} [clubId] Filter by club.
         * @param {string} [dateRange] Filter by date range.
         * @param {number} [contextEntries]
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardBySegmentId(id: number, gender?: string, ageGroup?: string, weightClass?: string, following?: boolean, clubId?: number, dateRange?: string, contextEntries?: number, page?: number, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLeaderboardBySegmentId.');
            }
            const localVarPath = `/segments/{id}/leaderboard`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (gender !== undefined) {
                localVarQueryParameter['gender'] = gender;
            }

            if (ageGroup !== undefined) {
                localVarQueryParameter['age_group'] = ageGroup;
            }

            if (weightClass !== undefined) {
                localVarQueryParameter['weight_class'] = weightClass;
            }

            if (following !== undefined) {
                localVarQueryParameter['following'] = following;
            }

            if (clubId !== undefined) {
                localVarQueryParameter['club_id'] = clubId;
            }

            if (dateRange !== undefined) {
                localVarQueryParameter['date_range'] = dateRange;
            }

            if (contextEntries !== undefined) {
                localVarQueryParameter['context_entries'] = contextEntries;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of the authenticated athlete's starred segments.
         * @summary List Starred Segments
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteStarredSegments(page?: number, perPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/segments/starred`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified segment.
         * @summary Get Segment
         * @param {number} id The identifier of the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSegmentById.');
            }
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stars/Unstars the given segment for the authenticated athlete.
         * @summary Star Segment
         * @param {number} id The identifier of the segment to star.
         * @param {boolean} starred If true, star the segment; if false, unstar the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starSegment(id: number, starred: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling starSegment.');
            }
            // verify required parameter 'starred' is not null or undefined
            if (starred === null || starred === undefined) {
                throw new RequiredError('starred','Required parameter starred was null or undefined when calling starSegment.');
            }
            const localVarPath = `/segments/{id}/starred`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (starred !== undefined) {
                localVarFormParams.set('starred', starred as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the top 10 segments matching a specified query.
         * @summary Explore segments
         * @param {Array&lt;number&gt;} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
         * @param {string} [activityType] Desired activity type.
         * @param {number} [minCat] The minimum climbing category.
         * @param {number} [maxCat] The maximum climbing category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreSegments(bounds: Array<number>, activityType?: string, minCat?: number, maxCat?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExplorerResponse> {
            const localVarFetchArgs = SegmentsApiFetchParamCreator(configuration).exploreSegments(bounds, activityType, minCat, maxCat, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified segment leaderboard.
         * @summary Get Segment Leaderboard
         * @param {number} id The identifier of the segment leaderboard.
         * @param {string} [gender] Filter by gender.
         * @param {string} [ageGroup] Premium Feature. Filter by age group.
         * @param {string} [weightClass] Premium Feature. Filter by weight class.
         * @param {boolean} [following] Filter by friends of the authenticated athlete.
         * @param {number} [clubId] Filter by club.
         * @param {string} [dateRange] Filter by date range.
         * @param {number} [contextEntries]
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardBySegmentId(id: number, gender?: string, ageGroup?: string, weightClass?: string, following?: boolean, clubId?: number, dateRange?: string, contextEntries?: number, page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SegmentLeaderboard> {
            const localVarFetchArgs = SegmentsApiFetchParamCreator(configuration).getLeaderboardBySegmentId(id, gender, ageGroup, weightClass, following, clubId, dateRange, contextEntries, page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List of the authenticated athlete's starred segments.
         * @summary List Starred Segments
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteStarredSegments(page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummarySegment>> {
            const localVarFetchArgs = SegmentsApiFetchParamCreator(configuration).getLoggedInAthleteStarredSegments(page, perPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified segment.
         * @summary Get Segment
         * @param {number} id The identifier of the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedSegment> {
            const localVarFetchArgs = SegmentsApiFetchParamCreator(configuration).getSegmentById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stars/Unstars the given segment for the authenticated athlete.
         * @summary Star Segment
         * @param {number} id The identifier of the segment to star.
         * @param {boolean} starred If true, star the segment; if false, unstar the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starSegment(id: number, starred: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedSegment> {
            const localVarFetchArgs = SegmentsApiFetchParamCreator(configuration).starSegment(id, starred, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the top 10 segments matching a specified query.
         * @summary Explore segments
         * @param {Array&lt;number&gt;} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
         * @param {string} [activityType] Desired activity type.
         * @param {number} [minCat] The minimum climbing category.
         * @param {number} [maxCat] The maximum climbing category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreSegments(bounds: Array<number>, activityType?: string, minCat?: number, maxCat?: number, options?: any) {
            return SegmentsApiFp(configuration).exploreSegments(bounds, activityType, minCat, maxCat, options)(fetch, basePath);
        },
        /**
         * Returns the specified segment leaderboard.
         * @summary Get Segment Leaderboard
         * @param {number} id The identifier of the segment leaderboard.
         * @param {string} [gender] Filter by gender.
         * @param {string} [ageGroup] Premium Feature. Filter by age group.
         * @param {string} [weightClass] Premium Feature. Filter by weight class.
         * @param {boolean} [following] Filter by friends of the authenticated athlete.
         * @param {number} [clubId] Filter by club.
         * @param {string} [dateRange] Filter by date range.
         * @param {number} [contextEntries]
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardBySegmentId(id: number, gender?: string, ageGroup?: string, weightClass?: string, following?: boolean, clubId?: number, dateRange?: string, contextEntries?: number, page?: number, perPage?: number, options?: any) {
            return SegmentsApiFp(configuration).getLeaderboardBySegmentId(id, gender, ageGroup, weightClass, following, clubId, dateRange, contextEntries, page, perPage, options)(fetch, basePath);
        },
        /**
         * List of the authenticated athlete's starred segments.
         * @summary List Starred Segments
         * @param {number} [page] Page number.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteStarredSegments(page?: number, perPage?: number, options?: any) {
            return SegmentsApiFp(configuration).getLoggedInAthleteStarredSegments(page, perPage, options)(fetch, basePath);
        },
        /**
         * Returns the specified segment.
         * @summary Get Segment
         * @param {number} id The identifier of the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentById(id: number, options?: any) {
            return SegmentsApiFp(configuration).getSegmentById(id, options)(fetch, basePath);
        },
        /**
         * Stars/Unstars the given segment for the authenticated athlete.
         * @summary Star Segment
         * @param {number} id The identifier of the segment to star.
         * @param {boolean} starred If true, star the segment; if false, unstar the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starSegment(id: number, starred: boolean, options?: any) {
            return SegmentsApiFp(configuration).starSegment(id, starred, options)(fetch, basePath);
        },
    };
};

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * Returns the top 10 segments matching a specified query.
     * @summary Explore segments
     * @param {} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
     * @param {} [activityType] Desired activity type.
     * @param {} [minCat] The minimum climbing category.
     * @param {} [maxCat] The maximum climbing category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public exploreSegments(bounds: Array<number>, activityType?: string, minCat?: number, maxCat?: number, options?: any) {
        return SegmentsApiFp(this.configuration).exploreSegments(bounds, activityType, minCat, maxCat, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the specified segment leaderboard.
     * @summary Get Segment Leaderboard
     * @param {} id The identifier of the segment leaderboard.
     * @param {} [gender] Filter by gender.
     * @param {} [ageGroup] Premium Feature. Filter by age group.
     * @param {} [weightClass] Premium Feature. Filter by weight class.
     * @param {} [following] Filter by friends of the authenticated athlete.
     * @param {} [clubId] Filter by club.
     * @param {} [dateRange] Filter by date range.
     * @param {} [contextEntries]
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getLeaderboardBySegmentId(id: number, gender?: string, ageGroup?: string, weightClass?: string, following?: boolean, clubId?: number, dateRange?: string, contextEntries?: number, page?: number, perPage?: number, options?: any) {
        return SegmentsApiFp(this.configuration).getLeaderboardBySegmentId(id, gender, ageGroup, weightClass, following, clubId, dateRange, contextEntries, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * List of the authenticated athlete's starred segments.
     * @summary List Starred Segments
     * @param {} [page] Page number.
     * @param {} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getLoggedInAthleteStarredSegments(page?: number, perPage?: number, options?: any) {
        return SegmentsApiFp(this.configuration).getLoggedInAthleteStarredSegments(page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the specified segment.
     * @summary Get Segment
     * @param {} id The identifier of the segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegmentById(id: number, options?: any) {
        return SegmentsApiFp(this.configuration).getSegmentById(id, options)(this.fetch, this.basePath);
    }

    /**
     * Stars/Unstars the given segment for the authenticated athlete.
     * @summary Star Segment
     * @param {} id The identifier of the segment to star.
     * @param {} starred If true, star the segment; if false, unstar the segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public starSegment(id: number, starred: boolean, options?: any) {
        return SegmentsApiFp(this.configuration).starSegment(id, starred, options)(this.fetch, this.basePath);
    }

}

/**
 * StreamsApi - fetch parameter creator
 * @export
 */
export const StreamsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the given activity's streams.
         * @summary Get Activity Streams
         * @param {number} id The identifier of the activity.
         * @param {Array&lt;string&gt;} keys Desired stream types.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStreams(id: number, keys: Array<string>, keyByType: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getActivityStreams.');
            }
            // verify required parameter 'keys' is not null or undefined
            if (keys === null || keys === undefined) {
                throw new RequiredError('keys','Required parameter keys was null or undefined when calling getActivityStreams.');
            }
            // verify required parameter 'keyByType' is not null or undefined
            if (keyByType === null || keyByType === undefined) {
                throw new RequiredError('keyByType','Required parameter keyByType was null or undefined when calling getActivityStreams.');
            }
            const localVarPath = `/activities/{id}/streams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (keys) {
                localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS["csv"]);
            }

            if (keyByType !== undefined) {
                localVarQueryParameter['key_by_type'] = keyByType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a set of streams for a segment effort completed by the authenticated athlete.
         * @summary Get segment effort streams
         * @param {number} id The identifier of the segment effort.
         * @param {Array&lt;string&gt;} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentEffortStreams(id: number, keys: Array<string>, keyByType: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSegmentEffortStreams.');
            }
            // verify required parameter 'keys' is not null or undefined
            if (keys === null || keys === undefined) {
                throw new RequiredError('keys','Required parameter keys was null or undefined when calling getSegmentEffortStreams.');
            }
            // verify required parameter 'keyByType' is not null or undefined
            if (keyByType === null || keyByType === undefined) {
                throw new RequiredError('keyByType','Required parameter keyByType was null or undefined when calling getSegmentEffortStreams.');
            }
            const localVarPath = `/segment_efforts/{id}/streams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (keys) {
                localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS["csv"]);
            }

            if (keyByType !== undefined) {
                localVarQueryParameter['key_by_type'] = keyByType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the given segment's streams.
         * @summary Get Segment Streams
         * @param {number} id The identifier of the segment.
         * @param {Array&lt;string&gt;} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentStreams(id: number, keys: Array<string>, keyByType: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSegmentStreams.');
            }
            // verify required parameter 'keys' is not null or undefined
            if (keys === null || keys === undefined) {
                throw new RequiredError('keys','Required parameter keys was null or undefined when calling getSegmentStreams.');
            }
            // verify required parameter 'keyByType' is not null or undefined
            if (keyByType === null || keyByType === undefined) {
                throw new RequiredError('keyByType','Required parameter keyByType was null or undefined when calling getSegmentStreams.');
            }
            const localVarPath = `/segments/{id}/streams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (keys) {
                localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS["csv"]);
            }

            if (keyByType !== undefined) {
                localVarQueryParameter['key_by_type'] = keyByType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamsApi - functional programming interface
 * @export
 */
export const StreamsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the given activity's streams.
         * @summary Get Activity Streams
         * @param {number} id The identifier of the activity.
         * @param {Array&lt;string&gt;} keys Desired stream types.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStreams(id: number, keys: Array<string>, keyByType: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamSet> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).getActivityStreams(id, keys, keyByType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a set of streams for a segment effort completed by the authenticated athlete.
         * @summary Get segment effort streams
         * @param {number} id The identifier of the segment effort.
         * @param {Array&lt;string&gt;} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentEffortStreams(id: number, keys: Array<string>, keyByType: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamSet> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).getSegmentEffortStreams(id, keys, keyByType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the given segment's streams.
         * @summary Get Segment Streams
         * @param {number} id The identifier of the segment.
         * @param {Array&lt;string&gt;} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentStreams(id: number, keys: Array<string>, keyByType: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamSet> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).getSegmentStreams(id, keys, keyByType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StreamsApi - factory interface
 * @export
 */
export const StreamsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the given activity's streams.
         * @summary Get Activity Streams
         * @param {number} id The identifier of the activity.
         * @param {Array&lt;string&gt;} keys Desired stream types.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStreams(id: number, keys: Array<string>, keyByType: boolean, options?: any) {
            return StreamsApiFp(configuration).getActivityStreams(id, keys, keyByType, options)(fetch, basePath);
        },
        /**
         * Returns a set of streams for a segment effort completed by the authenticated athlete.
         * @summary Get segment effort streams
         * @param {number} id The identifier of the segment effort.
         * @param {Array&lt;string&gt;} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentEffortStreams(id: number, keys: Array<string>, keyByType: boolean, options?: any) {
            return StreamsApiFp(configuration).getSegmentEffortStreams(id, keys, keyByType, options)(fetch, basePath);
        },
        /**
         * Returns the given segment's streams.
         * @summary Get Segment Streams
         * @param {number} id The identifier of the segment.
         * @param {Array&lt;string&gt;} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentStreams(id: number, keys: Array<string>, keyByType: boolean, options?: any) {
            return StreamsApiFp(configuration).getSegmentStreams(id, keys, keyByType, options)(fetch, basePath);
        },
    };
};

/**
 * StreamsApi - object-oriented interface
 * @export
 * @class StreamsApi
 * @extends {BaseAPI}
 */
export class StreamsApi extends BaseAPI {
    /**
     * Returns the given activity's streams.
     * @summary Get Activity Streams
     * @param {} id The identifier of the activity.
     * @param {} keys Desired stream types.
     * @param {} keyByType Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getActivityStreams(id: number, keys: Array<string>, keyByType: boolean, options?: any) {
        return StreamsApiFp(this.configuration).getActivityStreams(id, keys, keyByType, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a set of streams for a segment effort completed by the authenticated athlete.
     * @summary Get segment effort streams
     * @param {} id The identifier of the segment effort.
     * @param {} keys The types of streams to return.
     * @param {} keyByType Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getSegmentEffortStreams(id: number, keys: Array<string>, keyByType: boolean, options?: any) {
        return StreamsApiFp(this.configuration).getSegmentEffortStreams(id, keys, keyByType, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the given segment's streams.
     * @summary Get Segment Streams
     * @param {} id The identifier of the segment.
     * @param {} keys The types of streams to return.
     * @param {} keyByType Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getSegmentStreams(id: number, keys: Array<string>, keyByType: boolean, options?: any) {
        return StreamsApiFp(this.configuration).getSegmentStreams(id, keys, keyByType, options)(this.fetch, this.basePath);
    }

}

/**
 * UploadsApi - fetch parameter creator
 * @export
 */
export const UploadsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Uploads a new data file to create an activity from.
         * @summary Upload Activity
         * @param {any} [file] The uploaded file.
         * @param {string} [name] The desired name of the resulting activity.
         * @param {string} [description] The desired description of the resulting activity.
         * @param {number} [_private] Whether the resulting activity should be private.
         * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
         * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
         * @param {string} [dataType] The format of the uploaded file.
         * @param {string} [externalId] The desired external identifier of the resulting activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpload(file?: any, name?: string, description?: string, _private?: number, trainer?: string, commute?: string, dataType?: string, externalId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/uploads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('description', description as any);
            }

            if (_private !== undefined) {
                localVarFormParams.set('private', _private as any);
            }

            if (trainer !== undefined) {
                localVarFormParams.set('trainer', trainer as any);
            }

            if (commute !== undefined) {
                localVarFormParams.set('commute', commute as any);
            }

            if (dataType !== undefined) {
                localVarFormParams.set('data_type', dataType as any);
            }

            if (externalId !== undefined) {
                localVarFormParams.set('external_id', externalId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an upload for a given identifier.
         * @summary Get Upload
         * @param {number} uploadId The identifier of the upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadById(uploadId: number, options: any = {}): FetchArgs {
            // verify required parameter 'uploadId' is not null or undefined
            if (uploadId === null || uploadId === undefined) {
                throw new RequiredError('uploadId','Required parameter uploadId was null or undefined when calling getUploadById.');
            }
            const localVarPath = `/uploads/{uploadId}`
                .replace(`{${"uploadId"}}`, encodeURIComponent(String(uploadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Uploads a new data file to create an activity from.
         * @summary Upload Activity
         * @param {any} [file] The uploaded file.
         * @param {string} [name] The desired name of the resulting activity.
         * @param {string} [description] The desired description of the resulting activity.
         * @param {number} [_private] Whether the resulting activity should be private.
         * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
         * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
         * @param {string} [dataType] The format of the uploaded file.
         * @param {string} [externalId] The desired external identifier of the resulting activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpload(file?: any, name?: string, description?: string, _private?: number, trainer?: string, commute?: string, dataType?: string, externalId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Upload> {
            const localVarFetchArgs = UploadsApiFetchParamCreator(configuration).createUpload(file, name, description, _private, trainer, commute, dataType, externalId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an upload for a given identifier.
         * @summary Get Upload
         * @param {number} uploadId The identifier of the upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadById(uploadId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Upload> {
            const localVarFetchArgs = UploadsApiFetchParamCreator(configuration).getUploadById(uploadId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Uploads a new data file to create an activity from.
         * @summary Upload Activity
         * @param {any} [file] The uploaded file.
         * @param {string} [name] The desired name of the resulting activity.
         * @param {string} [description] The desired description of the resulting activity.
         * @param {number} [_private] Whether the resulting activity should be private.
         * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
         * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
         * @param {string} [dataType] The format of the uploaded file.
         * @param {string} [externalId] The desired external identifier of the resulting activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpload(file?: any, name?: string, description?: string, _private?: number, trainer?: string, commute?: string, dataType?: string, externalId?: string, options?: any) {
            return UploadsApiFp(configuration).createUpload(file, name, description, _private, trainer, commute, dataType, externalId, options)(fetch, basePath);
        },
        /**
         * Returns an upload for a given identifier.
         * @summary Get Upload
         * @param {number} uploadId The identifier of the upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadById(uploadId: number, options?: any) {
            return UploadsApiFp(configuration).getUploadById(uploadId, options)(fetch, basePath);
        },
    };
};

/**
 * UploadsApi - object-oriented interface
 * @export
 * @class UploadsApi
 * @extends {BaseAPI}
 */
export class UploadsApi extends BaseAPI {
    /**
     * Uploads a new data file to create an activity from.
     * @summary Upload Activity
     * @param {} [file] The uploaded file.
     * @param {} [name] The desired name of the resulting activity.
     * @param {} [description] The desired description of the resulting activity.
     * @param {} [_private] Whether the resulting activity should be private.
     * @param {} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
     * @param {} [commute] Whether the resulting activity should be tagged as a commute.
     * @param {} [dataType] The format of the uploaded file.
     * @param {} [externalId] The desired external identifier of the resulting activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public createUpload(file?: any, name?: string, description?: string, _private?: number, trainer?: string, commute?: string, dataType?: string, externalId?: string, options?: any) {
        return UploadsApiFp(this.configuration).createUpload(file, name, description, _private, trainer, commute, dataType, externalId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns an upload for a given identifier.
     * @summary Get Upload
     * @param {} uploadId The identifier of the upload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public getUploadById(uploadId: number, options?: any) {
        return UploadsApiFp(this.configuration).getUploadById(uploadId, options)(this.fetch, this.basePath);
    }

}

